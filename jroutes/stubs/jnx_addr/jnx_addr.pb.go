// Code generated by protoc-gen-go. DO NOT EDIT.
// source: jnx_addr.proto

package jnxBase

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

//
// The format of network addresses that the server is to use when
// responding to client requests.
type AddressFormat int32

const (
	//* Addreses in replies will be represented by strings
	AddressFormat_ADDRESS_STRING AddressFormat = 0
	//* Addreses in replies will be represented by binary data in
	//  byte arrays
	AddressFormat_ADDRESS_BYTES AddressFormat = 1
)

var AddressFormat_name = map[int32]string{
	0: "ADDRESS_STRING",
	1: "ADDRESS_BYTES",
}

var AddressFormat_value = map[string]int32{
	"ADDRESS_STRING": 0,
	"ADDRESS_BYTES":  1,
}

func (x AddressFormat) String() string {
	return proto.EnumName(AddressFormat_name, int32(x))
}

func (AddressFormat) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7a28e82f224d3fea, []int{0}
}

//
// Address family of a network address.
type AfType int32

const (
	AfType_AF_UNSPECIFIED AfType = 0
	AfType_AF_INET        AfType = 1
	AfType_AF_INET6       AfType = 2
	AfType_AF_MAC         AfType = 3
)

var AfType_name = map[int32]string{
	0: "AF_UNSPECIFIED",
	1: "AF_INET",
	2: "AF_INET6",
	3: "AF_MAC",
}

var AfType_value = map[string]int32{
	"AF_UNSPECIFIED": 0,
	"AF_INET":        1,
	"AF_INET6":       2,
	"AF_MAC":         3,
}

func (x AfType) String() string {
	return proto.EnumName(AfType_name, int32(x))
}

func (AfType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7a28e82f224d3fea, []int{1}
}

//
// An IP address, which may be either IPv4 or IPv6 and be respresented
// by either a string or array of binary bytes.
type IpAddress struct {
	// Types that are valid to be assigned to AddrFormat:
	//	*IpAddress_AddrString
	//	*IpAddress_AddrBytes
	AddrFormat           isIpAddress_AddrFormat `protobuf_oneof:"AddrFormat"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *IpAddress) Reset()         { *m = IpAddress{} }
func (m *IpAddress) String() string { return proto.CompactTextString(m) }
func (*IpAddress) ProtoMessage()    {}
func (*IpAddress) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a28e82f224d3fea, []int{0}
}

func (m *IpAddress) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IpAddress.Unmarshal(m, b)
}
func (m *IpAddress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IpAddress.Marshal(b, m, deterministic)
}
func (m *IpAddress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IpAddress.Merge(m, src)
}
func (m *IpAddress) XXX_Size() int {
	return xxx_messageInfo_IpAddress.Size(m)
}
func (m *IpAddress) XXX_DiscardUnknown() {
	xxx_messageInfo_IpAddress.DiscardUnknown(m)
}

var xxx_messageInfo_IpAddress proto.InternalMessageInfo

type isIpAddress_AddrFormat interface {
	isIpAddress_AddrFormat()
}

type IpAddress_AddrString struct {
	AddrString string `protobuf:"bytes,1,opt,name=addr_string,json=addrString,proto3,oneof"`
}

type IpAddress_AddrBytes struct {
	AddrBytes []byte `protobuf:"bytes,2,opt,name=addr_bytes,json=addrBytes,proto3,oneof"`
}

func (*IpAddress_AddrString) isIpAddress_AddrFormat() {}

func (*IpAddress_AddrBytes) isIpAddress_AddrFormat() {}

func (m *IpAddress) GetAddrFormat() isIpAddress_AddrFormat {
	if m != nil {
		return m.AddrFormat
	}
	return nil
}

func (m *IpAddress) GetAddrString() string {
	if x, ok := m.GetAddrFormat().(*IpAddress_AddrString); ok {
		return x.AddrString
	}
	return ""
}

func (m *IpAddress) GetAddrBytes() []byte {
	if x, ok := m.GetAddrFormat().(*IpAddress_AddrBytes); ok {
		return x.AddrBytes
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*IpAddress) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _IpAddress_OneofMarshaler, _IpAddress_OneofUnmarshaler, _IpAddress_OneofSizer, []interface{}{
		(*IpAddress_AddrString)(nil),
		(*IpAddress_AddrBytes)(nil),
	}
}

func _IpAddress_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*IpAddress)
	// AddrFormat
	switch x := m.AddrFormat.(type) {
	case *IpAddress_AddrString:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.AddrString)
	case *IpAddress_AddrBytes:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.AddrBytes)
	case nil:
	default:
		return fmt.Errorf("IpAddress.AddrFormat has unexpected type %T", x)
	}
	return nil
}

func _IpAddress_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*IpAddress)
	switch tag {
	case 1: // AddrFormat.addr_string
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.AddrFormat = &IpAddress_AddrString{x}
		return true, err
	case 2: // AddrFormat.addr_bytes
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.AddrFormat = &IpAddress_AddrBytes{x}
		return true, err
	default:
		return false, nil
	}
}

func _IpAddress_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*IpAddress)
	// AddrFormat
	switch x := m.AddrFormat.(type) {
	case *IpAddress_AddrString:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.AddrString)))
		n += len(x.AddrString)
	case *IpAddress_AddrBytes:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.AddrBytes)))
		n += len(x.AddrBytes)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

//
// An ethernet MAC address, which may be respresented by either a
// string or array of binary bytes.
type MacAddress struct {
	// Types that are valid to be assigned to AddrFormat:
	//	*MacAddress_AddrString
	//	*MacAddress_AddrBytes
	AddrFormat           isMacAddress_AddrFormat `protobuf_oneof:"AddrFormat"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *MacAddress) Reset()         { *m = MacAddress{} }
func (m *MacAddress) String() string { return proto.CompactTextString(m) }
func (*MacAddress) ProtoMessage()    {}
func (*MacAddress) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a28e82f224d3fea, []int{1}
}

func (m *MacAddress) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MacAddress.Unmarshal(m, b)
}
func (m *MacAddress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MacAddress.Marshal(b, m, deterministic)
}
func (m *MacAddress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MacAddress.Merge(m, src)
}
func (m *MacAddress) XXX_Size() int {
	return xxx_messageInfo_MacAddress.Size(m)
}
func (m *MacAddress) XXX_DiscardUnknown() {
	xxx_messageInfo_MacAddress.DiscardUnknown(m)
}

var xxx_messageInfo_MacAddress proto.InternalMessageInfo

type isMacAddress_AddrFormat interface {
	isMacAddress_AddrFormat()
}

type MacAddress_AddrString struct {
	AddrString string `protobuf:"bytes,1,opt,name=addr_string,json=addrString,proto3,oneof"`
}

type MacAddress_AddrBytes struct {
	AddrBytes []byte `protobuf:"bytes,2,opt,name=addr_bytes,json=addrBytes,proto3,oneof"`
}

func (*MacAddress_AddrString) isMacAddress_AddrFormat() {}

func (*MacAddress_AddrBytes) isMacAddress_AddrFormat() {}

func (m *MacAddress) GetAddrFormat() isMacAddress_AddrFormat {
	if m != nil {
		return m.AddrFormat
	}
	return nil
}

func (m *MacAddress) GetAddrString() string {
	if x, ok := m.GetAddrFormat().(*MacAddress_AddrString); ok {
		return x.AddrString
	}
	return ""
}

func (m *MacAddress) GetAddrBytes() []byte {
	if x, ok := m.GetAddrFormat().(*MacAddress_AddrBytes); ok {
		return x.AddrBytes
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*MacAddress) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _MacAddress_OneofMarshaler, _MacAddress_OneofUnmarshaler, _MacAddress_OneofSizer, []interface{}{
		(*MacAddress_AddrString)(nil),
		(*MacAddress_AddrBytes)(nil),
	}
}

func _MacAddress_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*MacAddress)
	// AddrFormat
	switch x := m.AddrFormat.(type) {
	case *MacAddress_AddrString:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.AddrString)
	case *MacAddress_AddrBytes:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.AddrBytes)
	case nil:
	default:
		return fmt.Errorf("MacAddress.AddrFormat has unexpected type %T", x)
	}
	return nil
}

func _MacAddress_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*MacAddress)
	switch tag {
	case 1: // AddrFormat.addr_string
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.AddrFormat = &MacAddress_AddrString{x}
		return true, err
	case 2: // AddrFormat.addr_bytes
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.AddrFormat = &MacAddress_AddrBytes{x}
		return true, err
	default:
		return false, nil
	}
}

func _MacAddress_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*MacAddress)
	// AddrFormat
	switch x := m.AddrFormat.(type) {
	case *MacAddress_AddrString:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.AddrString)))
		n += len(x.AddrString)
	case *MacAddress_AddrBytes:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.AddrBytes)))
		n += len(x.AddrBytes)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterEnum("jnxBase.AddressFormat", AddressFormat_name, AddressFormat_value)
	proto.RegisterEnum("jnxBase.AfType", AfType_name, AfType_value)
	proto.RegisterType((*IpAddress)(nil), "jnxBase.IpAddress")
	proto.RegisterType((*MacAddress)(nil), "jnxBase.MacAddress")
}

func init() { proto.RegisterFile("jnx_addr.proto", fileDescriptor_7a28e82f224d3fea) }

var fileDescriptor_7a28e82f224d3fea = []byte{
	// 239 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0xd0, 0xb1, 0x4e, 0xc3, 0x30,
	0x10, 0xc6, 0xf1, 0xb8, 0x48, 0x29, 0xb9, 0xa6, 0x95, 0xb9, 0xa9, 0x1b, 0xa5, 0x53, 0xd5, 0x81,
	0x05, 0xa9, 0xbb, 0x93, 0xd8, 0xd4, 0x43, 0x23, 0x14, 0x87, 0x81, 0x01, 0xac, 0x94, 0x04, 0x44,
	0x25, 0x92, 0xc8, 0xce, 0xd0, 0xbe, 0x3d, 0xb2, 0x09, 0x8f, 0xc0, 0xf8, 0xfd, 0x64, 0xff, 0x87,
	0x83, 0xc5, 0xa9, 0x3d, 0xeb, 0xaa, 0xae, 0xcd, 0x7d, 0x6f, 0xba, 0xa1, 0xc3, 0xe9, 0xa9, 0x3d,
	0x27, 0x95, 0x6d, 0xd6, 0xaf, 0x10, 0xc9, 0x9e, 0xd5, 0xb5, 0x69, 0xac, 0xc5, 0x3b, 0x98, 0xb9,
	0x37, 0xda, 0x0e, 0xe6, 0xab, 0xfd, 0x5c, 0x92, 0x15, 0xd9, 0x44, 0xfb, 0xa0, 0x00, 0x87, 0xca,
	0x1b, 0xde, 0x82, 0x5f, 0xfa, 0x78, 0x19, 0x1a, 0xbb, 0x9c, 0xac, 0xc8, 0x26, 0xde, 0x07, 0x45,
	0xe4, 0x2c, 0x71, 0x94, 0xc4, 0x00, 0x2e, 0x27, 0x3a, 0xf3, 0x5d, 0x0d, 0xeb, 0x37, 0x80, 0x43,
	0xf5, 0xfe, 0x6f, 0xfd, 0xed, 0x0e, 0xe6, 0x63, 0xfc, 0x17, 0x10, 0x61, 0xc1, 0xb2, 0xac, 0xe0,
	0x4a, 0x69, 0x55, 0x16, 0x32, 0x7f, 0xa4, 0x01, 0xde, 0xc0, 0xfc, 0xcf, 0x92, 0x97, 0x92, 0x2b,
	0x4a, 0xb6, 0x29, 0x84, 0xec, 0xa3, 0xbc, 0xf4, 0x8d, 0xff, 0x20, 0xf4, 0x73, 0xae, 0x9e, 0x78,
	0x2a, 0x85, 0xe4, 0x19, 0x0d, 0x70, 0x06, 0x53, 0x26, 0xb4, 0xcc, 0x79, 0x49, 0x09, 0xc6, 0x70,
	0x3d, 0x8e, 0x1d, 0x9d, 0x20, 0x40, 0xc8, 0x84, 0x3e, 0xb0, 0x94, 0x5e, 0x1d, 0x43, 0x7f, 0xcb,
	0x87, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xac, 0xc3, 0x40, 0xb8, 0x5d, 0x01, 0x00, 0x00,
}
