// Code generated by protoc-gen-go. DO NOT EDIT.
// source: bgp_route_service.proto

//
// This is part of the routing package.

package routing

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	jnx_addr "github.com/Juniper/vmx-docker-lwaftr/jroutes/stubs/jnx_addr"
	grpc "google.golang.org/grpc"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

//*
// Routing protocols
type RouteProtocol int32

const (
	//* Unspecified protocol default behavior dependent on API:
	//  For route change requests, PROTO_BGP_STATIC.
	//  For route get requests, match either PROTO_BGP or PROTO_BGP_STATIC.
	RouteProtocol_PROTO_UNSPECIFIED RouteProtocol = 0
	//* BGP dynamic routes
	RouteProtocol_PROTO_BGP RouteProtocol = 1
	//* BGP static programmed routes
	RouteProtocol_PROTO_BGP_STATIC RouteProtocol = 2
)

var RouteProtocol_name = map[int32]string{
	0: "PROTO_UNSPECIFIED",
	1: "PROTO_BGP",
	2: "PROTO_BGP_STATIC",
}

var RouteProtocol_value = map[string]int32{
	"PROTO_UNSPECIFIED": 0,
	"PROTO_BGP":         1,
	"PROTO_BGP_STATIC":  2,
}

func (x RouteProtocol) String() string {
	return proto.EnumName(RouteProtocol_name, int32(x))
}

func (RouteProtocol) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fa66c5a6e3bedc31, []int{0}
}

//*
// Route Operation Flag values that alter route add behavior.
// USE OF THIS TYPE IS DEPRECATED. Instead, use BgpRouteOperationFlags.
type RouteOperation int32

const (
	//*
	// Unspecified Operation, meaning no special operation specified.
	// USE OF THIS FLAG IS DEPRECATED. Instead, use BgpRouteOperationFlags.
	RouteOperation_UNSPECIFIED RouteOperation = 0 // Deprecated: Do not use.
	//*
	//  Route operation indicating whether to attach the well-known
	//  no-advertise community.
	//  No-advertise has the effect of instructing the route not to
	//  advertise the route further. The community may alternately be
	//  included in the community_list.
	//  USE OF THIS FLAG IS DEPRECATED. Instead, use BgpRouteOperationFlags.
	RouteOperation_NO_ADVERTISE RouteOperation = 1 // Deprecated: Do not use.
	//*
	//  Route operation indicating whether to attach the well-known no-export
	//  community. No-export has the effect of instructing the router
	//  not to advertise the route beyond the BGP confederation boundary.
	//  The community may alternately be included in the community_list.
	//  USE OF THIS FLAG IS DEPRECATED. Instead, use BgpRouteOperationFlags.
	RouteOperation_NO_EXPORT RouteOperation = 2 // Deprecated: Do not use.
	//*
	//  Route Operation indicating whether to use NH_REJECT for the route
	//  This makes sense to be set only when programming route in RR.
	//  This can be used to save memory when there are a high number of
	//  unique nexthops.
	//  USE OF THIS FLAG IS DEPRECATED. Instead, use BgpRouteOperationFlags.
	RouteOperation_USE_NH_REJECT RouteOperation = 4 // Deprecated: Do not use.
)

var RouteOperation_name = map[int32]string{
	0: "UNSPECIFIED",
	1: "NO_ADVERTISE",
	2: "NO_EXPORT",
	4: "USE_NH_REJECT",
}

var RouteOperation_value = map[string]int32{
	"UNSPECIFIED":   0,
	"NO_ADVERTISE":  1,
	"NO_EXPORT":     2,
	"USE_NH_REJECT": 4,
}

func (x RouteOperation) String() string {
	return proto.EnumName(RouteOperation_name, int32(x))
}

func (RouteOperation) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fa66c5a6e3bedc31, []int{1}
}

//*
// BGP peer type identifies if the associated route as an internal (IBGP)
// or external (EBGP) route.
type BgpPeerType int32

const (
	BgpPeerType_BGP_INTERNAL BgpPeerType = 0
	BgpPeerType_BGP_EXTERNAL BgpPeerType = 1
)

var BgpPeerType_name = map[int32]string{
	0: "BGP_INTERNAL",
	1: "BGP_EXTERNAL",
}

var BgpPeerType_value = map[string]int32{
	"BGP_INTERNAL": 0,
	"BGP_EXTERNAL": 1,
}

func (x BgpPeerType) String() string {
	return proto.EnumName(BgpPeerType_name, int32(x))
}

func (BgpPeerType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fa66c5a6e3bedc31, []int{2}
}

//* The route operation types for the monitor entries
type BgpRouteMonitorEntry_BgpRouteMonitorOper int32

const (
	//*
	//  A new route is being added or modified.
	//  bgp_route will contain the route info.
	BgpRouteMonitorEntry_ROUTE_UPDATE BgpRouteMonitorEntry_BgpRouteMonitorOper = 0
	//*
	//  An existing route is being removed.
	//  bgp_route will contain the route info.
	BgpRouteMonitorEntry_ROUTE_REMOVE BgpRouteMonitorEntry_BgpRouteMonitorOper = 1
	//*
	//  The initial set of route monitoring entires following a fresh
	//  client registration has been completed. bgp_route will be null for
	//  this operation.
	BgpRouteMonitorEntry_END_OF_RIBS BgpRouteMonitorEntry_BgpRouteMonitorOper = 2
)

var BgpRouteMonitorEntry_BgpRouteMonitorOper_name = map[int32]string{
	0: "ROUTE_UPDATE",
	1: "ROUTE_REMOVE",
	2: "END_OF_RIBS",
}

var BgpRouteMonitorEntry_BgpRouteMonitorOper_value = map[string]int32{
	"ROUTE_UPDATE": 0,
	"ROUTE_REMOVE": 1,
	"END_OF_RIBS":  2,
}

func (x BgpRouteMonitorEntry_BgpRouteMonitorOper) String() string {
	return proto.EnumName(BgpRouteMonitorEntry_BgpRouteMonitorOper_name, int32(x))
}

func (BgpRouteMonitorEntry_BgpRouteMonitorOper) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fa66c5a6e3bedc31, []int{8, 0}
}

// Possible return codes for route service initialize operations.
type BgpRouteInitializeReply_BgpRouteInitializeStatus int32

const (
	//* Request successfully completed. Note that no preexisting
	//  state for old clients with the same name was rebound.
	BgpRouteInitializeReply_SUCCESS BgpRouteInitializeReply_BgpRouteInitializeStatus = 0
	//* Request successfully completed AND preexisting routing state
	//  for an old client connection of the same name has been recovered
	//  and bound to this client connection.
	BgpRouteInitializeReply_SUCCESS_STATE_REBOUND BgpRouteInitializeReply_BgpRouteInitializeStatus = 1
	//* Request failed due to an internal server error.
	BgpRouteInitializeReply_INTERNAL_ERROR BgpRouteInitializeReply_BgpRouteInitializeStatus = 2
	//* Failed due to previous initialization operation.
	BgpRouteInitializeReply_ALREADY_INITIALIZED BgpRouteInitializeReply_BgpRouteInitializeStatus = 3
	//* Failed to find or create a gateway
	BgpRouteInitializeReply_GATEWAY_INVALID BgpRouteInitializeReply_BgpRouteInitializeStatus = 4
	//* Previous clean up work is pending try again later
	BgpRouteInitializeReply_CLEANUP_PENDING BgpRouteInitializeReply_BgpRouteInitializeStatus = 5
	//* The BGP protocol is not configured and initialized
	BgpRouteInitializeReply_BGP_NOT_READY BgpRouteInitializeReply_BgpRouteInitializeStatus = 6
)

var BgpRouteInitializeReply_BgpRouteInitializeStatus_name = map[int32]string{
	0: "SUCCESS",
	1: "SUCCESS_STATE_REBOUND",
	2: "INTERNAL_ERROR",
	3: "ALREADY_INITIALIZED",
	4: "GATEWAY_INVALID",
	5: "CLEANUP_PENDING",
	6: "BGP_NOT_READY",
}

var BgpRouteInitializeReply_BgpRouteInitializeStatus_value = map[string]int32{
	"SUCCESS":               0,
	"SUCCESS_STATE_REBOUND": 1,
	"INTERNAL_ERROR":        2,
	"ALREADY_INITIALIZED":   3,
	"GATEWAY_INVALID":       4,
	"CLEANUP_PENDING":       5,
	"BGP_NOT_READY":         6,
}

func (x BgpRouteInitializeReply_BgpRouteInitializeStatus) String() string {
	return proto.EnumName(BgpRouteInitializeReply_BgpRouteInitializeStatus_name, int32(x))
}

func (BgpRouteInitializeReply_BgpRouteInitializeStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fa66c5a6e3bedc31, []int{10, 0}
}

//* Possible return codes for route service cleanup operations.
type BgpRouteCleanupReply_BgpRouteCleanupStatus int32

const (
	//* Request successfully completed.
	BgpRouteCleanupReply_SUCCESS BgpRouteCleanupReply_BgpRouteCleanupStatus = 0
	//* Request failed due to an internal server error.
	BgpRouteCleanupReply_INTERNAL_ERROR BgpRouteCleanupReply_BgpRouteCleanupStatus = 1
	//* Request failed because there was no initialized state to
	//  cleanup.
	BgpRouteCleanupReply_NOT_INITIALIZED BgpRouteCleanupReply_BgpRouteCleanupStatus = 2
)

var BgpRouteCleanupReply_BgpRouteCleanupStatus_name = map[int32]string{
	0: "SUCCESS",
	1: "INTERNAL_ERROR",
	2: "NOT_INITIALIZED",
}

var BgpRouteCleanupReply_BgpRouteCleanupStatus_value = map[string]int32{
	"SUCCESS":         0,
	"INTERNAL_ERROR":  1,
	"NOT_INITIALIZED": 2,
}

func (x BgpRouteCleanupReply_BgpRouteCleanupStatus) String() string {
	return proto.EnumName(BgpRouteCleanupReply_BgpRouteCleanupStatus_name, int32(x))
}

func (BgpRouteCleanupReply_BgpRouteCleanupStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fa66c5a6e3bedc31, []int{12, 0}
}

//* Possible return codes for route add/modify/update/remove operations.
type BgpRouteOperReply_BgpRouteOperStatus int32

const (
	//* Request successfully completed in full.
	BgpRouteOperReply_SUCCESS BgpRouteOperReply_BgpRouteOperStatus = 0
	//* Request failed due to an internal server error.
	BgpRouteOperReply_INTERNAL_ERROR BgpRouteOperReply_BgpRouteOperStatus = 1
	//* The bgp route service has not been initialized
	BgpRouteOperReply_NOT_INITIALIZED BgpRouteOperReply_BgpRouteOperStatus = 2
	//* Request did not result in any operations
	BgpRouteOperReply_NO_OP BgpRouteOperReply_BgpRouteOperStatus = 3
	//* Request contained too many operations
	BgpRouteOperReply_TOO_MANY_OPS BgpRouteOperReply_BgpRouteOperStatus = 4
	//* Request contained an invalid table.
	BgpRouteOperReply_TABLE_INVALID BgpRouteOperReply_BgpRouteOperStatus = 5
	//* Request contained a table that was not ready for operations.
	BgpRouteOperReply_TABLE_NOT_READY BgpRouteOperReply_BgpRouteOperStatus = 6
	//* Request contained an invalid destination address prefix
	BgpRouteOperReply_PREFIX_INVALID BgpRouteOperReply_BgpRouteOperStatus = 7
	//* Request contained a destination prefix length too short for the
	//  supplied address/NLRI.
	BgpRouteOperReply_PREFIX_LEN_TOO_SHORT BgpRouteOperReply_BgpRouteOperStatus = 8
	//* Request contained a destination prefix length too long for the
	//  supplied address/NLRI.
	BgpRouteOperReply_PREFIX_LEN_TOO_LONG BgpRouteOperReply_BgpRouteOperStatus = 9
	//* The server did not have a valid gateway associated with the
	//  client.
	BgpRouteOperReply_GATEWAY_INVALID BgpRouteOperReply_BgpRouteOperStatus = 10
	//* Request contained an invalid nexthop.
	BgpRouteOperReply_NEXTHOP_INVALID BgpRouteOperReply_BgpRouteOperStatus = 11
	//* Request contained a nexthop with an invalild address.
	BgpRouteOperReply_NEXTHOP_ADDRESS_INVALID BgpRouteOperReply_BgpRouteOperStatus = 12
	//* Request to add paths exceeding maximum ECMP paths for a
	//  destination.
	BgpRouteOperReply_NEXTHOP_ECMP_LIMIT BgpRouteOperReply_BgpRouteOperStatus = 13
	//* Request contained an invalid community.
	BgpRouteOperReply_COMMUNITY_LIST_INVALID BgpRouteOperReply_BgpRouteOperStatus = 14
	//* Request contained an invalid AS path.
	BgpRouteOperReply_ASPATH_INVALID BgpRouteOperReply_BgpRouteOperStatus = 15
	//* Request contained a invalid label information.
	BgpRouteOperReply_LABEL_INFO_INVALID BgpRouteOperReply_BgpRouteOperStatus = 16
	//* Request contains a route that is already present in the table.
	BgpRouteOperReply_ROUTE_EXISTS BgpRouteOperReply_BgpRouteOperStatus = 17
	//* Request contains a route that is NOT present in the table.
	BgpRouteOperReply_ROUTE_NOT_FOUND BgpRouteOperReply_BgpRouteOperStatus = 18
	//* Request contains an invalid cluster list.
	BgpRouteOperReply_CLUSTER_LIST_INVALID BgpRouteOperReply_BgpRouteOperStatus = 19
	//* Request contains an invalid protocol. Only PROTO_UNSPECIFID
	//  or PROTO_BGP_STATIC are allowed in route change operations.
	BgpRouteOperReply_PROTOCOL_INVALID BgpRouteOperReply_BgpRouteOperStatus = 20
	//* Request contains a route that is NOT present in the table.
	BgpRouteOperReply_ROUTE_ADD_FAILED BgpRouteOperReply_BgpRouteOperStatus = 21
	//* The BGP protocol is not initialized and ready to accept
	//  route change operations.
	BgpRouteOperReply_BGP_NOT_READY BgpRouteOperReply_BgpRouteOperStatus = 22
	//* Request cannot be serviced until current requests are processed.
	BgpRouteOperReply_TRY_AGAIN BgpRouteOperReply_BgpRouteOperStatus = 23
	//* Request contains a parameter that is not currently supported.
	BgpRouteOperReply_REQUEST_UNSUPPORTED BgpRouteOperReply_BgpRouteOperStatus = 24
	//* Request contained an invalid BGP peer type.
	BgpRouteOperReply_PEER_TYPE_INVALID BgpRouteOperReply_BgpRouteOperStatus = 25
	//* SR-TE Segment Lists is invalid, like zero segment list
	BgpRouteOperReply_SEGMENT_LIST_INVALID BgpRouteOperReply_BgpRouteOperStatus = 26
	//* SR-TE Segment is invalid, like zero segment list
	BgpRouteOperReply_SEGMENT_INVALID BgpRouteOperReply_BgpRouteOperStatus = 27
	//* SR-TE Segment label is invalid; reserved label or label ttl > 255
	BgpRouteOperReply_SEGMENT_LABEL_INVALID BgpRouteOperReply_BgpRouteOperStatus = 28
	//* SR-TE Segment ID is invalid like segment type is not set
	BgpRouteOperReply_SEGMENT_ID_INVALID BgpRouteOperReply_BgpRouteOperStatus = 29
	//* Number of SR-TE Segment Lists exceeded limit (8)
	BgpRouteOperReply_SEGMENT_LIST_COUNT_INVALID BgpRouteOperReply_BgpRouteOperStatus = 30
	//* Number of SR-TE Segments exceeded limit (5)
	BgpRouteOperReply_SEGMENT_COUNT_INVALID BgpRouteOperReply_BgpRouteOperStatus = 31
	//* SRTE Route Data is not set.
	BgpRouteOperReply_SRTE_ROUTE_DATA_INVALID BgpRouteOperReply_BgpRouteOperStatus = 32
)

var BgpRouteOperReply_BgpRouteOperStatus_name = map[int32]string{
	0:  "SUCCESS",
	1:  "INTERNAL_ERROR",
	2:  "NOT_INITIALIZED",
	3:  "NO_OP",
	4:  "TOO_MANY_OPS",
	5:  "TABLE_INVALID",
	6:  "TABLE_NOT_READY",
	7:  "PREFIX_INVALID",
	8:  "PREFIX_LEN_TOO_SHORT",
	9:  "PREFIX_LEN_TOO_LONG",
	10: "GATEWAY_INVALID",
	11: "NEXTHOP_INVALID",
	12: "NEXTHOP_ADDRESS_INVALID",
	13: "NEXTHOP_ECMP_LIMIT",
	14: "COMMUNITY_LIST_INVALID",
	15: "ASPATH_INVALID",
	16: "LABEL_INFO_INVALID",
	17: "ROUTE_EXISTS",
	18: "ROUTE_NOT_FOUND",
	19: "CLUSTER_LIST_INVALID",
	20: "PROTOCOL_INVALID",
	21: "ROUTE_ADD_FAILED",
	22: "BGP_NOT_READY",
	23: "TRY_AGAIN",
	24: "REQUEST_UNSUPPORTED",
	25: "PEER_TYPE_INVALID",
	26: "SEGMENT_LIST_INVALID",
	27: "SEGMENT_INVALID",
	28: "SEGMENT_LABEL_INVALID",
	29: "SEGMENT_ID_INVALID",
	30: "SEGMENT_LIST_COUNT_INVALID",
	31: "SEGMENT_COUNT_INVALID",
	32: "SRTE_ROUTE_DATA_INVALID",
}

var BgpRouteOperReply_BgpRouteOperStatus_value = map[string]int32{
	"SUCCESS":                    0,
	"INTERNAL_ERROR":             1,
	"NOT_INITIALIZED":            2,
	"NO_OP":                      3,
	"TOO_MANY_OPS":               4,
	"TABLE_INVALID":              5,
	"TABLE_NOT_READY":            6,
	"PREFIX_INVALID":             7,
	"PREFIX_LEN_TOO_SHORT":       8,
	"PREFIX_LEN_TOO_LONG":        9,
	"GATEWAY_INVALID":            10,
	"NEXTHOP_INVALID":            11,
	"NEXTHOP_ADDRESS_INVALID":    12,
	"NEXTHOP_ECMP_LIMIT":         13,
	"COMMUNITY_LIST_INVALID":     14,
	"ASPATH_INVALID":             15,
	"LABEL_INFO_INVALID":         16,
	"ROUTE_EXISTS":               17,
	"ROUTE_NOT_FOUND":            18,
	"CLUSTER_LIST_INVALID":       19,
	"PROTOCOL_INVALID":           20,
	"ROUTE_ADD_FAILED":           21,
	"BGP_NOT_READY":              22,
	"TRY_AGAIN":                  23,
	"REQUEST_UNSUPPORTED":        24,
	"PEER_TYPE_INVALID":          25,
	"SEGMENT_LIST_INVALID":       26,
	"SEGMENT_INVALID":            27,
	"SEGMENT_LABEL_INVALID":      28,
	"SEGMENT_ID_INVALID":         29,
	"SEGMENT_LIST_COUNT_INVALID": 30,
	"SEGMENT_COUNT_INVALID":      31,
	"SRTE_ROUTE_DATA_INVALID":    32,
}

func (x BgpRouteOperReply_BgpRouteOperStatus) String() string {
	return proto.EnumName(BgpRouteOperReply_BgpRouteOperStatus_name, int32(x))
}

func (BgpRouteOperReply_BgpRouteOperStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fa66c5a6e3bedc31, []int{16, 0}
}

//* Possible return codes for route get operations.
type BgpRouteGetReply_BgpRouteGetStatus int32

const (
	//* Request successfully completed in full.
	BgpRouteGetReply_SUCCESS BgpRouteGetReply_BgpRouteGetStatus = 0
	//* Request failed due to an internal server error.
	BgpRouteGetReply_INTERNAL_ERROR BgpRouteGetReply_BgpRouteGetStatus = 1
	//* Request failed because there was no initialized state to
	//  cleanup.
	BgpRouteGetReply_NOT_INITIALIZED BgpRouteGetReply_BgpRouteGetStatus = 2
	//* Request contained an invalid table.
	BgpRouteGetReply_TABLE_INVALID BgpRouteGetReply_BgpRouteGetStatus = 3
	//* Request contained a table that was not ready for operations.
	BgpRouteGetReply_TABLE_NOT_READY BgpRouteGetReply_BgpRouteGetStatus = 4
	//* Request contained an invalid destination address prefix
	BgpRouteGetReply_PREFIX_INVALID BgpRouteGetReply_BgpRouteGetStatus = 5
	//* Request contained a destination prefix length too short for the
	//  supplied address/NLRI.
	BgpRouteGetReply_PREFIX_LEN_TOO_SHORT BgpRouteGetReply_BgpRouteGetStatus = 6
	//* Request contained a destination prefix length too long for the
	//  supplied address/NLRI.
	BgpRouteGetReply_PREFIX_LEN_TOO_LONG BgpRouteGetReply_BgpRouteGetStatus = 7
	//* Request contained a route that does not match
	//  destinations in the routing table.
	BgpRouteGetReply_ROUTE_NOT_FOUND BgpRouteGetReply_BgpRouteGetStatus = 8
	//* Request specified an invalid protocol to match
	BgpRouteGetReply_PROTOCOL_INVALID BgpRouteGetReply_BgpRouteGetStatus = 9
	//* Request does not contain valid route match parameters
	BgpRouteGetReply_ROUTE_INVALID BgpRouteGetReply_BgpRouteGetStatus = 10
	//* Request contains a parameter that is not currently supported.
	BgpRouteGetReply_REQUEST_UNSUPPORTED BgpRouteGetReply_BgpRouteGetStatus = 11
	//* Request cannot be serviced until current requests are processed.
	BgpRouteGetReply_TRY_AGAIN BgpRouteGetReply_BgpRouteGetStatus = 12
	//* Request contains a route_count that exceeds the max of 1000
	BgpRouteGetReply_ROUTE_COUNT_INVALID BgpRouteGetReply_BgpRouteGetStatus = 13
	//* Request contained an invalid community.
	BgpRouteGetReply_COMMUNITY_LIST_INVALID BgpRouteGetReply_BgpRouteGetStatus = 14
)

var BgpRouteGetReply_BgpRouteGetStatus_name = map[int32]string{
	0:  "SUCCESS",
	1:  "INTERNAL_ERROR",
	2:  "NOT_INITIALIZED",
	3:  "TABLE_INVALID",
	4:  "TABLE_NOT_READY",
	5:  "PREFIX_INVALID",
	6:  "PREFIX_LEN_TOO_SHORT",
	7:  "PREFIX_LEN_TOO_LONG",
	8:  "ROUTE_NOT_FOUND",
	9:  "PROTOCOL_INVALID",
	10: "ROUTE_INVALID",
	11: "REQUEST_UNSUPPORTED",
	12: "TRY_AGAIN",
	13: "ROUTE_COUNT_INVALID",
	14: "COMMUNITY_LIST_INVALID",
}

var BgpRouteGetReply_BgpRouteGetStatus_value = map[string]int32{
	"SUCCESS":                0,
	"INTERNAL_ERROR":         1,
	"NOT_INITIALIZED":        2,
	"TABLE_INVALID":          3,
	"TABLE_NOT_READY":        4,
	"PREFIX_INVALID":         5,
	"PREFIX_LEN_TOO_SHORT":   6,
	"PREFIX_LEN_TOO_LONG":    7,
	"ROUTE_NOT_FOUND":        8,
	"PROTOCOL_INVALID":       9,
	"ROUTE_INVALID":          10,
	"REQUEST_UNSUPPORTED":    11,
	"TRY_AGAIN":              12,
	"ROUTE_COUNT_INVALID":    13,
	"COMMUNITY_LIST_INVALID": 14,
}

func (x BgpRouteGetReply_BgpRouteGetStatus) String() string {
	return proto.EnumName(BgpRouteGetReply_BgpRouteGetStatus_name, int32(x))
}

func (BgpRouteGetReply_BgpRouteGetStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fa66c5a6e3bedc31, []int{17, 0}
}

//* Possible return codes for route get operations.
type BgpRouteMonitorRegisterReply_BgpRouteMonitorRegisterStatus int32

const (
	//* Request successfully completed in full.
	BgpRouteMonitorRegisterReply_SUCCESS BgpRouteMonitorRegisterReply_BgpRouteMonitorRegisterStatus = 0
	//* Request failed due to an internal server error.
	BgpRouteMonitorRegisterReply_INTERNAL_ERROR BgpRouteMonitorRegisterReply_BgpRouteMonitorRegisterStatus = 1
	//* The bgp route service has not been initialized
	BgpRouteMonitorRegisterReply_NOT_INITIALIZED BgpRouteMonitorRegisterReply_BgpRouteMonitorRegisterStatus = 2
	//* Too many clients or BMP stations are already registered.
	BgpRouteMonitorRegisterReply_REGISTRATIONS_EXCEEDED BgpRouteMonitorRegisterReply_BgpRouteMonitorRegisterStatus = 3
	//* Client is already registered.
	BgpRouteMonitorRegisterReply_ALREADY_REGISTERED BgpRouteMonitorRegisterReply_BgpRouteMonitorRegisterStatus = 4
	//* Request contains a route_count that exceeds the max of 1000
	BgpRouteMonitorRegisterReply_ROUTE_COUNT_INVALID BgpRouteMonitorRegisterReply_BgpRouteMonitorRegisterStatus = 5
	//* Request contains invalid address format.
	BgpRouteMonitorRegisterReply_ADDRESS_FORMAT_INVALID BgpRouteMonitorRegisterReply_BgpRouteMonitorRegisterStatus = 6
	//* Request contains invalid table format.
	BgpRouteMonitorRegisterReply_TABLE_FORMAT_INVALID BgpRouteMonitorRegisterReply_BgpRouteMonitorRegisterStatus = 7
)

var BgpRouteMonitorRegisterReply_BgpRouteMonitorRegisterStatus_name = map[int32]string{
	0: "SUCCESS",
	1: "INTERNAL_ERROR",
	2: "NOT_INITIALIZED",
	3: "REGISTRATIONS_EXCEEDED",
	4: "ALREADY_REGISTERED",
	5: "ROUTE_COUNT_INVALID",
	6: "ADDRESS_FORMAT_INVALID",
	7: "TABLE_FORMAT_INVALID",
}

var BgpRouteMonitorRegisterReply_BgpRouteMonitorRegisterStatus_value = map[string]int32{
	"SUCCESS":                0,
	"INTERNAL_ERROR":         1,
	"NOT_INITIALIZED":        2,
	"REGISTRATIONS_EXCEEDED": 3,
	"ALREADY_REGISTERED":     4,
	"ROUTE_COUNT_INVALID":    5,
	"ADDRESS_FORMAT_INVALID": 6,
	"TABLE_FORMAT_INVALID":   7,
}

func (x BgpRouteMonitorRegisterReply_BgpRouteMonitorRegisterStatus) String() string {
	return proto.EnumName(BgpRouteMonitorRegisterReply_BgpRouteMonitorRegisterStatus_name, int32(x))
}

func (BgpRouteMonitorRegisterReply_BgpRouteMonitorRegisterStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fa66c5a6e3bedc31, []int{19, 0}
}

//* Possible return codes for route unregister operation.
type BgpRouteMonitorUnregisterReply_BgpRouteMonitorUnregisterStatus int32

const (
	//* Request successfully completed in full.
	BgpRouteMonitorUnregisterReply_SUCCESS BgpRouteMonitorUnregisterReply_BgpRouteMonitorUnregisterStatus = 0
	//* Request failed due to an internal server error.
	BgpRouteMonitorUnregisterReply_INTERNAL_ERROR BgpRouteMonitorUnregisterReply_BgpRouteMonitorUnregisterStatus = 1
	//* The bgp route service has not been initialized
	BgpRouteMonitorUnregisterReply_NOT_INITIALIZED BgpRouteMonitorUnregisterReply_BgpRouteMonitorUnregisterStatus = 2
	//* Client is already registered.
	BgpRouteMonitorUnregisterReply_NOT_REGISTERED BgpRouteMonitorUnregisterReply_BgpRouteMonitorUnregisterStatus = 3
)

var BgpRouteMonitorUnregisterReply_BgpRouteMonitorUnregisterStatus_name = map[int32]string{
	0: "SUCCESS",
	1: "INTERNAL_ERROR",
	2: "NOT_INITIALIZED",
	3: "NOT_REGISTERED",
}

var BgpRouteMonitorUnregisterReply_BgpRouteMonitorUnregisterStatus_value = map[string]int32{
	"SUCCESS":         0,
	"INTERNAL_ERROR":  1,
	"NOT_INITIALIZED": 2,
	"NOT_REGISTERED":  3,
}

func (x BgpRouteMonitorUnregisterReply_BgpRouteMonitorUnregisterStatus) String() string {
	return proto.EnumName(BgpRouteMonitorUnregisterReply_BgpRouteMonitorUnregisterStatus_name, int32(x))
}

func (BgpRouteMonitorUnregisterReply_BgpRouteMonitorUnregisterStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fa66c5a6e3bedc31, []int{21, 0}
}

//* Possible return codes for route unregister operation.
type BgpRouteMonitorRefreshReply_BgpRouteMonitorRefreshStatus int32

const (
	//* Request successfully completed in full.
	BgpRouteMonitorRefreshReply_SUCCESS BgpRouteMonitorRefreshReply_BgpRouteMonitorRefreshStatus = 0
	//* Request failed due to an internal server error.
	BgpRouteMonitorRefreshReply_INTERNAL_ERROR BgpRouteMonitorRefreshReply_BgpRouteMonitorRefreshStatus = 1
	//* The bgp route service has not been initialized
	BgpRouteMonitorRefreshReply_NOT_INITIALIZED BgpRouteMonitorRefreshReply_BgpRouteMonitorRefreshStatus = 2
	//* Client is already registered.
	BgpRouteMonitorRefreshReply_NOT_REGISTERED BgpRouteMonitorRefreshReply_BgpRouteMonitorRefreshStatus = 3
)

var BgpRouteMonitorRefreshReply_BgpRouteMonitorRefreshStatus_name = map[int32]string{
	0: "SUCCESS",
	1: "INTERNAL_ERROR",
	2: "NOT_INITIALIZED",
	3: "NOT_REGISTERED",
}

var BgpRouteMonitorRefreshReply_BgpRouteMonitorRefreshStatus_value = map[string]int32{
	"SUCCESS":         0,
	"INTERNAL_ERROR":  1,
	"NOT_INITIALIZED": 2,
	"NOT_REGISTERED":  3,
}

func (x BgpRouteMonitorRefreshReply_BgpRouteMonitorRefreshStatus) String() string {
	return proto.EnumName(BgpRouteMonitorRefreshReply_BgpRouteMonitorRefreshStatus_name, int32(x))
}

func (BgpRouteMonitorRefreshReply_BgpRouteMonitorRefreshStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fa66c5a6e3bedc31, []int{23, 0}
}

//*
// Route Operation Flag values that alter route add behavior.
//
// This data type replaces and deprecates RouteOperation.
// New applications should use BgpRouteOperationFlags exclusively and instead
// of RouteOperation.
//
// Backwards compatibility: In BgpRouteUpdateRequest messages, if both
// bgp_routes[].route_oper_flags and bgp_routes[].route_flags are initialized,
// then only the new route_flags will be processed and the old route_oper_flags
// will be ignored. If only  route_oper_flags or route_flags are initialized,
// then that initialized  flags message will be processed.
// In BgpRouteGetReply and BgpRouteMontiorEntry messages, both the
// route_oper_flags and route_flags will be set within the bgp_routes[] and
// bgp_route fields (respectively), indicating the same flags.
type BgpRouteOperationFlags struct {
	//*
	//  Route operation indicating whether to attach the well-known
	//  no-advertise community.
	//  No-advertise has the effect of instructing the route not to
	//  advertise the route further. The community may alternately be
	//  included in the community_list.
	NoAdvertise bool `protobuf:"varint,1,opt,name=no_advertise,json=noAdvertise,proto3" json:"no_advertise,omitempty"`
	//*
	//  Route operation indicating whether to attach the well-known no-export
	//  community. No-export has the effect of instructing the router
	//  not to advertise the route beyond the BGP confederation boundary.
	//  The community may alternately be included in the community_list.
	NoExport bool `protobuf:"varint,2,opt,name=no_export,json=noExport,proto3" json:"no_export,omitempty"`
	//*
	//  Route Operation indicating whether to use NH_REJECT for the route
	//  This makes sense to be set only when programming route in RR.
	//  This can be used to save memory when there are a high number of
	//  unique nexthops.
	UseNexthopReject     bool     `protobuf:"varint,3,opt,name=use_nexthop_reject,json=useNexthopReject,proto3" json:"use_nexthop_reject,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BgpRouteOperationFlags) Reset()         { *m = BgpRouteOperationFlags{} }
func (m *BgpRouteOperationFlags) String() string { return proto.CompactTextString(m) }
func (*BgpRouteOperationFlags) ProtoMessage()    {}
func (*BgpRouteOperationFlags) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa66c5a6e3bedc31, []int{0}
}

func (m *BgpRouteOperationFlags) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BgpRouteOperationFlags.Unmarshal(m, b)
}
func (m *BgpRouteOperationFlags) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BgpRouteOperationFlags.Marshal(b, m, deterministic)
}
func (m *BgpRouteOperationFlags) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BgpRouteOperationFlags.Merge(m, src)
}
func (m *BgpRouteOperationFlags) XXX_Size() int {
	return xxx_messageInfo_BgpRouteOperationFlags.Size(m)
}
func (m *BgpRouteOperationFlags) XXX_DiscardUnknown() {
	xxx_messageInfo_BgpRouteOperationFlags.DiscardUnknown(m)
}

var xxx_messageInfo_BgpRouteOperationFlags proto.InternalMessageInfo

func (m *BgpRouteOperationFlags) GetNoAdvertise() bool {
	if m != nil {
		return m.NoAdvertise
	}
	return false
}

func (m *BgpRouteOperationFlags) GetNoExport() bool {
	if m != nil {
		return m.NoExport
	}
	return false
}

func (m *BgpRouteOperationFlags) GetUseNexthopReject() bool {
	if m != nil {
		return m.UseNexthopReject
	}
	return false
}

//*
// A generic 32-bit unsigned value that implicitly carries an indication
// of whether any value has been set or not.
type BgpAttrib32 struct {
	//* 32-bit unsigned value
	Value                uint32   `protobuf:"varint,1,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BgpAttrib32) Reset()         { *m = BgpAttrib32{} }
func (m *BgpAttrib32) String() string { return proto.CompactTextString(m) }
func (*BgpAttrib32) ProtoMessage()    {}
func (*BgpAttrib32) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa66c5a6e3bedc31, []int{1}
}

func (m *BgpAttrib32) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BgpAttrib32.Unmarshal(m, b)
}
func (m *BgpAttrib32) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BgpAttrib32.Marshal(b, m, deterministic)
}
func (m *BgpAttrib32) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BgpAttrib32.Merge(m, src)
}
func (m *BgpAttrib32) XXX_Size() int {
	return xxx_messageInfo_BgpAttrib32.Size(m)
}
func (m *BgpAttrib32) XXX_DiscardUnknown() {
	xxx_messageInfo_BgpAttrib32.DiscardUnknown(m)
}

var xxx_messageInfo_BgpAttrib32 proto.InternalMessageInfo

func (m *BgpAttrib32) GetValue() uint32 {
	if m != nil {
		return m.Value
	}
	return 0
}

//*
// A generic 64-bit unsigned value that implicitly carries an indication
// of whether any value has been set or not.
type BgpAttrib64 struct {
	//* 64-bit unsigned value
	Value                uint64   `protobuf:"varint,1,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BgpAttrib64) Reset()         { *m = BgpAttrib64{} }
func (m *BgpAttrib64) String() string { return proto.CompactTextString(m) }
func (*BgpAttrib64) ProtoMessage()    {}
func (*BgpAttrib64) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa66c5a6e3bedc31, []int{2}
}

func (m *BgpAttrib64) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BgpAttrib64.Unmarshal(m, b)
}
func (m *BgpAttrib64) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BgpAttrib64.Marshal(b, m, deterministic)
}
func (m *BgpAttrib64) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BgpAttrib64.Merge(m, src)
}
func (m *BgpAttrib64) XXX_Size() int {
	return xxx_messageInfo_BgpAttrib64.Size(m)
}
func (m *BgpAttrib64) XXX_DiscardUnknown() {
	xxx_messageInfo_BgpAttrib64.DiscardUnknown(m)
}

var xxx_messageInfo_BgpAttrib64 proto.InternalMessageInfo

func (m *BgpAttrib64) GetValue() uint64 {
	if m != nil {
		return m.Value
	}
	return 0
}

//*
// A single communty is a string identifying a regular, extended,
// or well-known community name or values with no whitepace.
//
// The communities will be recognized:
//
// Well-known communities:
//    no-export
//    no-advertise
//    no-export-confed
//    llgr-stale
//    no-llgr
//
// RFC 1997 comunities:
//    domain-id:ipaddress:0
//    domain-id-vendor:
//    <n>:<n>
//
// Route targets extended communities:
//    target:ipv4-address:16 bit#
//    target:16bit#:32bit#
//    target:as2b:16bit#:32bit#
//    target:as4b:32bit#:16bit#
//
// Origin extended communities:
//    origin:ipv4-address:16 bit#
//    origin:16bit#:32bit#
//
// Bandwidth management extended communities:
//    bandwidth:16bit#:bw
//    {traffic-rate}:16 bit#:bw
//
// Redirect extended communities:
//    redirect:ipv4-address:16 bit#
//    redirect:16bit#:32bit#
//
// Tunnel encapsulation extended communities:
//    encapsulation:0L:tunnel-type
//
type Community struct {
	//* A string that uniquely identifies a single regular, extended, or
	//  well-known community. A community string must not exceeed
	//  1023 characters. REQUIRED
	CommunityString      string   `protobuf:"bytes,1,opt,name=community_string,json=communityString,proto3" json:"community_string,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Community) Reset()         { *m = Community{} }
func (m *Community) String() string { return proto.CompactTextString(m) }
func (*Community) ProtoMessage()    {}
func (*Community) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa66c5a6e3bedc31, []int{3}
}

func (m *Community) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Community.Unmarshal(m, b)
}
func (m *Community) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Community.Marshal(b, m, deterministic)
}
func (m *Community) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Community.Merge(m, src)
}
func (m *Community) XXX_Size() int {
	return xxx_messageInfo_Community.Size(m)
}
func (m *Community) XXX_DiscardUnknown() {
	xxx_messageInfo_Community.DiscardUnknown(m)
}

var xxx_messageInfo_Community proto.InternalMessageInfo

func (m *Community) GetCommunityString() string {
	if m != nil {
		return m.CommunityString
	}
	return ""
}

//*
// A list of communities.
type CommunityList struct {
	//* An unordered list of zero, one, or more individual communities.
	//  A Community list may not exceed 256 communities
	ComList              []*Community `protobuf:"bytes,1,rep,name=com_list,json=comList,proto3" json:"com_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *CommunityList) Reset()         { *m = CommunityList{} }
func (m *CommunityList) String() string { return proto.CompactTextString(m) }
func (*CommunityList) ProtoMessage()    {}
func (*CommunityList) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa66c5a6e3bedc31, []int{4}
}

func (m *CommunityList) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CommunityList.Unmarshal(m, b)
}
func (m *CommunityList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CommunityList.Marshal(b, m, deterministic)
}
func (m *CommunityList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommunityList.Merge(m, src)
}
func (m *CommunityList) XXX_Size() int {
	return xxx_messageInfo_CommunityList.Size(m)
}
func (m *CommunityList) XXX_DiscardUnknown() {
	xxx_messageInfo_CommunityList.DiscardUnknown(m)
}

var xxx_messageInfo_CommunityList proto.InternalMessageInfo

func (m *CommunityList) GetComList() []*Community {
	if m != nil {
		return m.ComList
	}
	return nil
}

//*
// AS path through which the route was learned.
//
// An AS Path is a string composed of an series of AS numbers
// separated by whitespace special delimiters.
// The following special delimiting characters are used for signifying
// confederations, confederation-sets, and AS-sets:
//
//     [ ] - Brackets enclose the local AS number associated with the AS set
//     if more than one AS number is configured on the routing device,
//     or if AS path prepending is configured.
//
//     ( ) - Parentheses enclose a confederation.
//
//     ( [ ] ) - Parentheses and brackets enclose a confederation set.
//
// Programmed AS Paths implicitly have path origin IGP.
type AsPath struct {
	//* A string listing AS numbers separated by whitespace and special
	//  delimiter charaters (see message as-path). An AS Path must not
	//  exceed 1023 characters. REQUIRED
	AspathString         string   `protobuf:"bytes,1,opt,name=aspath_string,json=aspathString,proto3" json:"aspath_string,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AsPath) Reset()         { *m = AsPath{} }
func (m *AsPath) String() string { return proto.CompactTextString(m) }
func (*AsPath) ProtoMessage()    {}
func (*AsPath) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa66c5a6e3bedc31, []int{5}
}

func (m *AsPath) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AsPath.Unmarshal(m, b)
}
func (m *AsPath) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AsPath.Marshal(b, m, deterministic)
}
func (m *AsPath) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AsPath.Merge(m, src)
}
func (m *AsPath) XXX_Size() int {
	return xxx_messageInfo_AsPath.Size(m)
}
func (m *AsPath) XXX_DiscardUnknown() {
	xxx_messageInfo_AsPath.DiscardUnknown(m)
}

var xxx_messageInfo_AsPath proto.InternalMessageInfo

func (m *AsPath) GetAspathString() string {
	if m != nil {
		return m.AspathString
	}
	return ""
}

//*
// Route matching parameters provide the key for identifying
// BGP routes. Programmed BGP-Static routes must be unique
// for the bgp_route_match paramaters. Dynamic BGP routes may
// may have multiple matches to a given set of bgp_route_match
// parameters.
type BgpRouteMatch struct {
	//* Destination prefix of the route. REQUIRED
	DestPrefix *RoutePrefix `protobuf:"bytes,1,opt,name=dest_prefix,json=destPrefix,proto3" json:"dest_prefix,omitempty"`
	//* Destination prefix length in bits. REQUIRED
	DestPrefixLen uint32 `protobuf:"varint,2,opt,name=dest_prefix_len,json=destPrefixLen,proto3" json:"dest_prefix_len,omitempty"`
	//* Route table specified by either name or ID. REQUIRED
	Table *RouteTable `protobuf:"bytes,3,opt,name=table,proto3" json:"table,omitempty"`
	//* Protocol that installed the route in the table.
	Protocol RouteProtocol `protobuf:"varint,4,opt,name=protocol,proto3,enum=routing.RouteProtocol" json:"protocol,omitempty"`
	//* Path cookie value differentiates routes with the same destination.
	//  The cookie may be any unsigned 64-bit value. Optional (default is 0,
	//  which indicates that cookie is not evaluated for matching)
	PathCookie uint64 `protobuf:"varint,5,opt,name=path_cookie,json=pathCookie,proto3" json:"path_cookie,omitempty"`
	//* Commumity string list associated with route. The list could be
	//  a single/multiple community string or a regular expression.
	//  This is an optional parameter. If this list is null then all
	//  route with or without community would be returned.
	Communities          *CommunityList `protobuf:"bytes,6,opt,name=communities,proto3" json:"communities,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *BgpRouteMatch) Reset()         { *m = BgpRouteMatch{} }
func (m *BgpRouteMatch) String() string { return proto.CompactTextString(m) }
func (*BgpRouteMatch) ProtoMessage()    {}
func (*BgpRouteMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa66c5a6e3bedc31, []int{6}
}

func (m *BgpRouteMatch) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BgpRouteMatch.Unmarshal(m, b)
}
func (m *BgpRouteMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BgpRouteMatch.Marshal(b, m, deterministic)
}
func (m *BgpRouteMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BgpRouteMatch.Merge(m, src)
}
func (m *BgpRouteMatch) XXX_Size() int {
	return xxx_messageInfo_BgpRouteMatch.Size(m)
}
func (m *BgpRouteMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_BgpRouteMatch.DiscardUnknown(m)
}

var xxx_messageInfo_BgpRouteMatch proto.InternalMessageInfo

func (m *BgpRouteMatch) GetDestPrefix() *RoutePrefix {
	if m != nil {
		return m.DestPrefix
	}
	return nil
}

func (m *BgpRouteMatch) GetDestPrefixLen() uint32 {
	if m != nil {
		return m.DestPrefixLen
	}
	return 0
}

func (m *BgpRouteMatch) GetTable() *RouteTable {
	if m != nil {
		return m.Table
	}
	return nil
}

func (m *BgpRouteMatch) GetProtocol() RouteProtocol {
	if m != nil {
		return m.Protocol
	}
	return RouteProtocol_PROTO_UNSPECIFIED
}

func (m *BgpRouteMatch) GetPathCookie() uint64 {
	if m != nil {
		return m.PathCookie
	}
	return 0
}

func (m *BgpRouteMatch) GetCommunities() *CommunityList {
	if m != nil {
		return m.Communities
	}
	return nil
}

//*
// A route entry specifying a single route destination and BGP path
// along with the route attributes for that path.
type BgpRouteEntry struct {
	//* Destination prefix of the route. REQUIRED
	DestPrefix *RoutePrefix `protobuf:"bytes,1,opt,name=dest_prefix,json=destPrefix,proto3" json:"dest_prefix,omitempty"`
	//* Destination prefix length in bits. REQUIRED
	DestPrefixLen uint32 `protobuf:"varint,2,opt,name=dest_prefix_len,json=destPrefixLen,proto3" json:"dest_prefix_len,omitempty"`
	//* Route table specified by either name or ID. REQUIRED
	Table *RouteTable `protobuf:"bytes,3,opt,name=table,proto3" json:"table,omitempty"`
	//* Protocol that installed the route in the table.
	//  In get requests, the only valid values are PROTO_UNSPECIFIED or
	//  PROTO_BGP_STATIC.
	Protocol RouteProtocol `protobuf:"varint,4,opt,name=protocol,proto3,enum=routing.RouteProtocol" json:"protocol,omitempty"`
	//* Path cookie value differentiates routes with the same destination.
	//  The cookie may be any unsigned 64-bit value. Optional (default is 0)
	PathCookie uint64 `protobuf:"varint,5,opt,name=path_cookie,json=pathCookie,proto3" json:"path_cookie,omitempty"`
	//* Route Preference, also known as administrative distance, is a
	//  unsigned value in the range from 0 through 4,294,967,295 (2^32 -1).
	//  Lower values of route preference are preferred. Optional (default,
	//  route preference for programmed BGP-Static routes is 5)
	RoutePreference *BgpAttrib32 `protobuf:"bytes,6,opt,name=route_preference,json=routePreference,proto3" json:"route_preference,omitempty"`
	//* Local Preference is an unsigned value in the range from
	//  0 through 4,294,967,295 (2^32 - 1). Higher values of local preference
	//  are prefered. Optional (default is 100)
	LocalPreference *BgpAttrib32 `protobuf:"bytes,7,opt,name=local_preference,json=localPreference,proto3" json:"local_preference,omitempty"`
	//* Multi-Exit Discriminator (MED) is an unsigned value in the range
	//  from 0 through 4,294,967,295 (2^32 -1). Lower values of MED
	//  are preferred. Optional (by default no MED is advertised)
	Med *BgpAttrib32 `protobuf:"bytes,8,opt,name=med,proto3" json:"med,omitempty"`
	//* AIGP Distance is an 64-bit unsigned value in the range from 0 through
	//  (2^64 - 1). Lower values of AIGP distance are preferred.
	//  Optional (by default, no AIGP distance is advertised)
	AigpDistance *BgpAttrib64 `protobuf:"bytes,9,opt,name=aigp_distance,json=aigpDistance,proto3" json:"aigp_distance,omitempty"`
	//* Label information may be provided either as a single VPN label in
	//  L3VPN tables, or as a full label stack in BGP-Labeled-Unicast tables.
	//  BGP-LU tables for L3VPN should provide a label stack with the VPN label
	//  as the bottom-most label in the stack. Optional (by default, no label
	//  information is advertised)
	//
	// Types that are valid to be assigned to LabelInfo:
	//	*BgpRouteEntry_VpnLabel
	//	*BgpRouteEntry_Labels
	LabelInfo isBgpRouteEntry_LabelInfo `protobuf_oneof:"LabelInfo"`
	//* List of route communities. Optional (by default, no communities are
	//  advertised.
	Communities *CommunityList `protobuf:"bytes,12,opt,name=communities,proto3" json:"communities,omitempty"`
	//* AS Path for the route. Optional (by default, no no AS path is
	//  advertised
	Aspath *AsPath `protobuf:"bytes,13,opt,name=aspath,proto3" json:"aspath,omitempty"`
	//* BGP originator ID is a unsigned 32-bit BGP Identifier value,
	//  as per RFC 6286, encoded in network byte order. Optional
	// (by default, no originator ID is advertised)
	OriginatorId *BgpAttrib32 `protobuf:"bytes,14,opt,name=originator_id,json=originatorId,proto3" json:"originator_id,omitempty"`
	//* BGP cluster list, list of cluster IDs specifying the
	//  path of route reflectors though which this route has traversed.
	//  Optional (by default, no cluster list is advertised)
	ClusterList []*BgpAttrib32 `protobuf:"bytes,15,rep,name=cluster_list,json=clusterList,proto3" json:"cluster_list,omitempty"`
	//* BGP Cluster ID is a unsigned 32-bit BGP Identifier value,
	//  as per RFC 6286, encoded in network byte order. Cluster ID is
	//  append to the cluster_list for advertisement with reflected routes.
	//  Optional (by default, no cluster ID is advertised)
	ClusterId *BgpAttrib32 `protobuf:"bytes,16,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	//*
	//  Flag indicating the route operations defined in RouteOperation enum
	//  These values can be ORed to indicate a combination of operations.
	//  USE OF THIS FIELD IS DEPRECATED. Instead, use route_flags.
	RouteOperFlag uint32 `protobuf:"varint,17,opt,name=route_oper_flag,json=routeOperFlag,proto3" json:"route_oper_flag,omitempty"` // Deprecated: Do not use.
	//* Protocol next-hop(s) for the route. If multiple next-hops are given,
	//  the route will be treated as a BGP multipath for load balancing.
	//  NOTE: Multipath is not currently supported by the API and
	//  an error will be returned when adding/changing a route with more than
	//  one next-hop. REQUIRED
	ProtocolNexthops []*jnx_addr.IpAddress `protobuf:"bytes,18,rep,name=protocol_nexthops,json=protocolNexthops,proto3" json:"protocol_nexthops,omitempty"`
	//* BGP Peer type for this route. Optional (default INTERNAL)
	RouteType BgpPeerType `protobuf:"varint,19,opt,name=route_type,json=routeType,proto3,enum=routing.BgpPeerType" json:"route_type,omitempty"`
	//*
	// Flags for routes. These flags are generally non-mutually exclusive
	// states.
	// Optional (default is no flags).
	RouteFlags *BgpRouteOperationFlags `protobuf:"bytes,20,opt,name=route_flags,json=routeFlags,proto3" json:"route_flags,omitempty"`
	//*
	// Address family specific route data.
	// Mandatory for address family for which it is defined (e.g. SRTE).
	RouteData            *AddressFamilySpecificData `protobuf:"bytes,21,opt,name=route_data,json=routeData,proto3" json:"route_data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *BgpRouteEntry) Reset()         { *m = BgpRouteEntry{} }
func (m *BgpRouteEntry) String() string { return proto.CompactTextString(m) }
func (*BgpRouteEntry) ProtoMessage()    {}
func (*BgpRouteEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa66c5a6e3bedc31, []int{7}
}

func (m *BgpRouteEntry) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BgpRouteEntry.Unmarshal(m, b)
}
func (m *BgpRouteEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BgpRouteEntry.Marshal(b, m, deterministic)
}
func (m *BgpRouteEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BgpRouteEntry.Merge(m, src)
}
func (m *BgpRouteEntry) XXX_Size() int {
	return xxx_messageInfo_BgpRouteEntry.Size(m)
}
func (m *BgpRouteEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_BgpRouteEntry.DiscardUnknown(m)
}

var xxx_messageInfo_BgpRouteEntry proto.InternalMessageInfo

func (m *BgpRouteEntry) GetDestPrefix() *RoutePrefix {
	if m != nil {
		return m.DestPrefix
	}
	return nil
}

func (m *BgpRouteEntry) GetDestPrefixLen() uint32 {
	if m != nil {
		return m.DestPrefixLen
	}
	return 0
}

func (m *BgpRouteEntry) GetTable() *RouteTable {
	if m != nil {
		return m.Table
	}
	return nil
}

func (m *BgpRouteEntry) GetProtocol() RouteProtocol {
	if m != nil {
		return m.Protocol
	}
	return RouteProtocol_PROTO_UNSPECIFIED
}

func (m *BgpRouteEntry) GetPathCookie() uint64 {
	if m != nil {
		return m.PathCookie
	}
	return 0
}

func (m *BgpRouteEntry) GetRoutePreference() *BgpAttrib32 {
	if m != nil {
		return m.RoutePreference
	}
	return nil
}

func (m *BgpRouteEntry) GetLocalPreference() *BgpAttrib32 {
	if m != nil {
		return m.LocalPreference
	}
	return nil
}

func (m *BgpRouteEntry) GetMed() *BgpAttrib32 {
	if m != nil {
		return m.Med
	}
	return nil
}

func (m *BgpRouteEntry) GetAigpDistance() *BgpAttrib64 {
	if m != nil {
		return m.AigpDistance
	}
	return nil
}

type isBgpRouteEntry_LabelInfo interface {
	isBgpRouteEntry_LabelInfo()
}

type BgpRouteEntry_VpnLabel struct {
	VpnLabel uint32 `protobuf:"varint,10,opt,name=vpn_label,json=vpnLabel,proto3,oneof"`
}

type BgpRouteEntry_Labels struct {
	Labels *LabelStack `protobuf:"bytes,11,opt,name=labels,proto3,oneof"`
}

func (*BgpRouteEntry_VpnLabel) isBgpRouteEntry_LabelInfo() {}

func (*BgpRouteEntry_Labels) isBgpRouteEntry_LabelInfo() {}

func (m *BgpRouteEntry) GetLabelInfo() isBgpRouteEntry_LabelInfo {
	if m != nil {
		return m.LabelInfo
	}
	return nil
}

func (m *BgpRouteEntry) GetVpnLabel() uint32 {
	if x, ok := m.GetLabelInfo().(*BgpRouteEntry_VpnLabel); ok {
		return x.VpnLabel
	}
	return 0
}

func (m *BgpRouteEntry) GetLabels() *LabelStack {
	if x, ok := m.GetLabelInfo().(*BgpRouteEntry_Labels); ok {
		return x.Labels
	}
	return nil
}

func (m *BgpRouteEntry) GetCommunities() *CommunityList {
	if m != nil {
		return m.Communities
	}
	return nil
}

func (m *BgpRouteEntry) GetAspath() *AsPath {
	if m != nil {
		return m.Aspath
	}
	return nil
}

func (m *BgpRouteEntry) GetOriginatorId() *BgpAttrib32 {
	if m != nil {
		return m.OriginatorId
	}
	return nil
}

func (m *BgpRouteEntry) GetClusterList() []*BgpAttrib32 {
	if m != nil {
		return m.ClusterList
	}
	return nil
}

func (m *BgpRouteEntry) GetClusterId() *BgpAttrib32 {
	if m != nil {
		return m.ClusterId
	}
	return nil
}

// Deprecated: Do not use.
func (m *BgpRouteEntry) GetRouteOperFlag() uint32 {
	if m != nil {
		return m.RouteOperFlag
	}
	return 0
}

func (m *BgpRouteEntry) GetProtocolNexthops() []*jnx_addr.IpAddress {
	if m != nil {
		return m.ProtocolNexthops
	}
	return nil
}

func (m *BgpRouteEntry) GetRouteType() BgpPeerType {
	if m != nil {
		return m.RouteType
	}
	return BgpPeerType_BGP_INTERNAL
}

func (m *BgpRouteEntry) GetRouteFlags() *BgpRouteOperationFlags {
	if m != nil {
		return m.RouteFlags
	}
	return nil
}

func (m *BgpRouteEntry) GetRouteData() *AddressFamilySpecificData {
	if m != nil {
		return m.RouteData
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*BgpRouteEntry) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _BgpRouteEntry_OneofMarshaler, _BgpRouteEntry_OneofUnmarshaler, _BgpRouteEntry_OneofSizer, []interface{}{
		(*BgpRouteEntry_VpnLabel)(nil),
		(*BgpRouteEntry_Labels)(nil),
	}
}

func _BgpRouteEntry_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*BgpRouteEntry)
	// LabelInfo
	switch x := m.LabelInfo.(type) {
	case *BgpRouteEntry_VpnLabel:
		b.EncodeVarint(10<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.VpnLabel))
	case *BgpRouteEntry_Labels:
		b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Labels); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("BgpRouteEntry.LabelInfo has unexpected type %T", x)
	}
	return nil
}

func _BgpRouteEntry_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*BgpRouteEntry)
	switch tag {
	case 10: // LabelInfo.vpn_label
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.LabelInfo = &BgpRouteEntry_VpnLabel{uint32(x)}
		return true, err
	case 11: // LabelInfo.labels
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LabelStack)
		err := b.DecodeMessage(msg)
		m.LabelInfo = &BgpRouteEntry_Labels{msg}
		return true, err
	default:
		return false, nil
	}
}

func _BgpRouteEntry_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*BgpRouteEntry)
	// LabelInfo
	switch x := m.LabelInfo.(type) {
	case *BgpRouteEntry_VpnLabel:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.VpnLabel))
	case *BgpRouteEntry_Labels:
		s := proto.Size(x.Labels)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

//*
// A monitoring entry for a single BGP route streamed from BGP when the
// client has registered for route monitoring with BgpRouteMonitorRegister().
type BgpRouteMonitorEntry struct {
	//* The operation type
	Operation BgpRouteMonitorEntry_BgpRouteMonitorOper `protobuf:"varint,1,opt,name=operation,proto3,enum=routing.BgpRouteMonitorEntry_BgpRouteMonitorOper" json:"operation,omitempty"`
	//*
	//  The route that is the subject of this route monitoring operation.
	//  If the operation is END_OF_RIBS, then no route will be
	//  present here.
	BgpRoute             *BgpRouteEntry `protobuf:"bytes,2,opt,name=bgp_route,json=bgpRoute,proto3" json:"bgp_route,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *BgpRouteMonitorEntry) Reset()         { *m = BgpRouteMonitorEntry{} }
func (m *BgpRouteMonitorEntry) String() string { return proto.CompactTextString(m) }
func (*BgpRouteMonitorEntry) ProtoMessage()    {}
func (*BgpRouteMonitorEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa66c5a6e3bedc31, []int{8}
}

func (m *BgpRouteMonitorEntry) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BgpRouteMonitorEntry.Unmarshal(m, b)
}
func (m *BgpRouteMonitorEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BgpRouteMonitorEntry.Marshal(b, m, deterministic)
}
func (m *BgpRouteMonitorEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BgpRouteMonitorEntry.Merge(m, src)
}
func (m *BgpRouteMonitorEntry) XXX_Size() int {
	return xxx_messageInfo_BgpRouteMonitorEntry.Size(m)
}
func (m *BgpRouteMonitorEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_BgpRouteMonitorEntry.DiscardUnknown(m)
}

var xxx_messageInfo_BgpRouteMonitorEntry proto.InternalMessageInfo

func (m *BgpRouteMonitorEntry) GetOperation() BgpRouteMonitorEntry_BgpRouteMonitorOper {
	if m != nil {
		return m.Operation
	}
	return BgpRouteMonitorEntry_ROUTE_UPDATE
}

func (m *BgpRouteMonitorEntry) GetBgpRoute() *BgpRouteEntry {
	if m != nil {
		return m.BgpRoute
	}
	return nil
}

//*
// Request to initialize the BGP route service. No parameters are needed.
type BgpRouteInitializeRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BgpRouteInitializeRequest) Reset()         { *m = BgpRouteInitializeRequest{} }
func (m *BgpRouteInitializeRequest) String() string { return proto.CompactTextString(m) }
func (*BgpRouteInitializeRequest) ProtoMessage()    {}
func (*BgpRouteInitializeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa66c5a6e3bedc31, []int{9}
}

func (m *BgpRouteInitializeRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BgpRouteInitializeRequest.Unmarshal(m, b)
}
func (m *BgpRouteInitializeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BgpRouteInitializeRequest.Marshal(b, m, deterministic)
}
func (m *BgpRouteInitializeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BgpRouteInitializeRequest.Merge(m, src)
}
func (m *BgpRouteInitializeRequest) XXX_Size() int {
	return xxx_messageInfo_BgpRouteInitializeRequest.Size(m)
}
func (m *BgpRouteInitializeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BgpRouteInitializeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BgpRouteInitializeRequest proto.InternalMessageInfo

//*
// BGP route service initialize reply containing the status of the operation.
// Replies indicate to the client whether any old routing state was
// recovered and rebound to this connection.
type BgpRouteInitializeReply struct {
	//* The final return code for the request.
	Status BgpRouteInitializeReply_BgpRouteInitializeStatus `protobuf:"varint,1,opt,name=status,proto3,enum=routing.BgpRouteInitializeReply_BgpRouteInitializeStatus" json:"status,omitempty"`
	//* Valid only when status is CLEANUP_PENDING and will indicate the number
	// of routes on the gateway, giving an idea of the time required to cleanup
	GwNRoutes            uint32   `protobuf:"varint,2,opt,name=gw_n_routes,json=gwNRoutes,proto3" json:"gw_n_routes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BgpRouteInitializeReply) Reset()         { *m = BgpRouteInitializeReply{} }
func (m *BgpRouteInitializeReply) String() string { return proto.CompactTextString(m) }
func (*BgpRouteInitializeReply) ProtoMessage()    {}
func (*BgpRouteInitializeReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa66c5a6e3bedc31, []int{10}
}

func (m *BgpRouteInitializeReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BgpRouteInitializeReply.Unmarshal(m, b)
}
func (m *BgpRouteInitializeReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BgpRouteInitializeReply.Marshal(b, m, deterministic)
}
func (m *BgpRouteInitializeReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BgpRouteInitializeReply.Merge(m, src)
}
func (m *BgpRouteInitializeReply) XXX_Size() int {
	return xxx_messageInfo_BgpRouteInitializeReply.Size(m)
}
func (m *BgpRouteInitializeReply) XXX_DiscardUnknown() {
	xxx_messageInfo_BgpRouteInitializeReply.DiscardUnknown(m)
}

var xxx_messageInfo_BgpRouteInitializeReply proto.InternalMessageInfo

func (m *BgpRouteInitializeReply) GetStatus() BgpRouteInitializeReply_BgpRouteInitializeStatus {
	if m != nil {
		return m.Status
	}
	return BgpRouteInitializeReply_SUCCESS
}

func (m *BgpRouteInitializeReply) GetGwNRoutes() uint32 {
	if m != nil {
		return m.GwNRoutes
	}
	return 0
}

//*
// Request to reset the BGP route service.
// Any routes that were added by the client will be removed during the
// cleanup of the client's state. No parameters are needed.
type BgpRouteCleanupRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BgpRouteCleanupRequest) Reset()         { *m = BgpRouteCleanupRequest{} }
func (m *BgpRouteCleanupRequest) String() string { return proto.CompactTextString(m) }
func (*BgpRouteCleanupRequest) ProtoMessage()    {}
func (*BgpRouteCleanupRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa66c5a6e3bedc31, []int{11}
}

func (m *BgpRouteCleanupRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BgpRouteCleanupRequest.Unmarshal(m, b)
}
func (m *BgpRouteCleanupRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BgpRouteCleanupRequest.Marshal(b, m, deterministic)
}
func (m *BgpRouteCleanupRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BgpRouteCleanupRequest.Merge(m, src)
}
func (m *BgpRouteCleanupRequest) XXX_Size() int {
	return xxx_messageInfo_BgpRouteCleanupRequest.Size(m)
}
func (m *BgpRouteCleanupRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BgpRouteCleanupRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BgpRouteCleanupRequest proto.InternalMessageInfo

//*
// Route service cleanup reply containing the status of the operation.
type BgpRouteCleanupReply struct {
	//* The final return code for the request.
	Status               BgpRouteCleanupReply_BgpRouteCleanupStatus `protobuf:"varint,1,opt,name=status,proto3,enum=routing.BgpRouteCleanupReply_BgpRouteCleanupStatus" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                   `json:"-"`
	XXX_unrecognized     []byte                                     `json:"-"`
	XXX_sizecache        int32                                      `json:"-"`
}

func (m *BgpRouteCleanupReply) Reset()         { *m = BgpRouteCleanupReply{} }
func (m *BgpRouteCleanupReply) String() string { return proto.CompactTextString(m) }
func (*BgpRouteCleanupReply) ProtoMessage()    {}
func (*BgpRouteCleanupReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa66c5a6e3bedc31, []int{12}
}

func (m *BgpRouteCleanupReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BgpRouteCleanupReply.Unmarshal(m, b)
}
func (m *BgpRouteCleanupReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BgpRouteCleanupReply.Marshal(b, m, deterministic)
}
func (m *BgpRouteCleanupReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BgpRouteCleanupReply.Merge(m, src)
}
func (m *BgpRouteCleanupReply) XXX_Size() int {
	return xxx_messageInfo_BgpRouteCleanupReply.Size(m)
}
func (m *BgpRouteCleanupReply) XXX_DiscardUnknown() {
	xxx_messageInfo_BgpRouteCleanupReply.DiscardUnknown(m)
}

var xxx_messageInfo_BgpRouteCleanupReply proto.InternalMessageInfo

func (m *BgpRouteCleanupReply) GetStatus() BgpRouteCleanupReply_BgpRouteCleanupStatus {
	if m != nil {
		return m.Status
	}
	return BgpRouteCleanupReply_SUCCESS
}

//*
// Route add, modify, or update operation request parameters.
type BgpRouteUpdateRequest struct {
	//* One or more programmed bgp routes to add, udpate, or modify.
	//  REQUIRED
	BgpRoutes            []*BgpRouteEntry `protobuf:"bytes,1,rep,name=bgp_routes,json=bgpRoutes,proto3" json:"bgp_routes,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *BgpRouteUpdateRequest) Reset()         { *m = BgpRouteUpdateRequest{} }
func (m *BgpRouteUpdateRequest) String() string { return proto.CompactTextString(m) }
func (*BgpRouteUpdateRequest) ProtoMessage()    {}
func (*BgpRouteUpdateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa66c5a6e3bedc31, []int{13}
}

func (m *BgpRouteUpdateRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BgpRouteUpdateRequest.Unmarshal(m, b)
}
func (m *BgpRouteUpdateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BgpRouteUpdateRequest.Marshal(b, m, deterministic)
}
func (m *BgpRouteUpdateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BgpRouteUpdateRequest.Merge(m, src)
}
func (m *BgpRouteUpdateRequest) XXX_Size() int {
	return xxx_messageInfo_BgpRouteUpdateRequest.Size(m)
}
func (m *BgpRouteUpdateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BgpRouteUpdateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BgpRouteUpdateRequest proto.InternalMessageInfo

func (m *BgpRouteUpdateRequest) GetBgpRoutes() []*BgpRouteEntry {
	if m != nil {
		return m.BgpRoutes
	}
	return nil
}

//*
// Route remove operation request parameters.
type BgpRouteRemoveRequest struct {
	//* If or_longer is FALSE only routes for the exact destination
	//  prefix and prefix length will be matched.
	//  If or_longer is TRUE, routes for the given destination prefix
	//  or longer prefixes will be matched.
	//  Optional (default is FALSE)
	OrLonger bool `protobuf:"varint,1,opt,name=or_longer,json=orLonger,proto3" json:"or_longer,omitempty"`
	//* One or more programmed bgp routes to remove. REQUIRED
	BgpRoutes            []*BgpRouteMatch `protobuf:"bytes,2,rep,name=bgp_routes,json=bgpRoutes,proto3" json:"bgp_routes,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *BgpRouteRemoveRequest) Reset()         { *m = BgpRouteRemoveRequest{} }
func (m *BgpRouteRemoveRequest) String() string { return proto.CompactTextString(m) }
func (*BgpRouteRemoveRequest) ProtoMessage()    {}
func (*BgpRouteRemoveRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa66c5a6e3bedc31, []int{14}
}

func (m *BgpRouteRemoveRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BgpRouteRemoveRequest.Unmarshal(m, b)
}
func (m *BgpRouteRemoveRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BgpRouteRemoveRequest.Marshal(b, m, deterministic)
}
func (m *BgpRouteRemoveRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BgpRouteRemoveRequest.Merge(m, src)
}
func (m *BgpRouteRemoveRequest) XXX_Size() int {
	return xxx_messageInfo_BgpRouteRemoveRequest.Size(m)
}
func (m *BgpRouteRemoveRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BgpRouteRemoveRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BgpRouteRemoveRequest proto.InternalMessageInfo

func (m *BgpRouteRemoveRequest) GetOrLonger() bool {
	if m != nil {
		return m.OrLonger
	}
	return false
}

func (m *BgpRouteRemoveRequest) GetBgpRoutes() []*BgpRouteMatch {
	if m != nil {
		return m.BgpRoutes
	}
	return nil
}

//*
// Route get operation request parameters.
type BgpRouteGetRequest struct {
	//* Route matching parameters
	BgpRoute *BgpRouteMatch `protobuf:"bytes,1,opt,name=bgp_route,json=bgpRoute,proto3" json:"bgp_route,omitempty"`
	//* If or_longer is FALSE only routes for the exact destination
	//  prefix and prefix length will be matched.
	//  If or_longer is TRUE, routes for the given destination prefix
	//  or longer prefixes will be matched.
	//  Optional (default is FALSE)
	OrLonger bool `protobuf:"varint,2,opt,name=or_longer,json=orLonger,proto3" json:"or_longer,omitempty"`
	//* If active_only is TRUE, inactive and hidden routes for a matching
	//  prefix will be omitted from the results. If FALSE, inactive
	//  and hidden routes are also returned. Optional (default is FALSE)
	ActiveOnly bool `protobuf:"varint,3,opt,name=active_only,json=activeOnly,proto3" json:"active_only,omitempty"`
	//* The format for IP addresses in the replies to this request.
	//  Optional (default is string)
	ReplyAddressFormat jnx_addr.AddressFormat `protobuf:"varint,4,opt,name=reply_address_format,json=replyAddressFormat,proto3,enum=jnxBase.AddressFormat" json:"reply_address_format,omitempty"`
	//* The format for IP addresses in the replies to this request.
	//  Optional (default is string)
	ReplyTableFormat RouteTableFormat `protobuf:"varint,5,opt,name=reply_table_format,json=replyTableFormat,proto3,enum=routing.RouteTableFormat" json:"reply_table_format,omitempty"`
	//* The maximum number of routes requested in each reply.
	//  Replies will be streamed in multiple RPCs each having no more
	//  routes than given by this value. Counts from 1 through the maximum of
	//  1000 may be specified. A value of zero indcates that
	//  the server will choose an appropriate. Optional (default 1)
	RouteCount           uint32   `protobuf:"varint,6,opt,name=route_count,json=routeCount,proto3" json:"route_count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BgpRouteGetRequest) Reset()         { *m = BgpRouteGetRequest{} }
func (m *BgpRouteGetRequest) String() string { return proto.CompactTextString(m) }
func (*BgpRouteGetRequest) ProtoMessage()    {}
func (*BgpRouteGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa66c5a6e3bedc31, []int{15}
}

func (m *BgpRouteGetRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BgpRouteGetRequest.Unmarshal(m, b)
}
func (m *BgpRouteGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BgpRouteGetRequest.Marshal(b, m, deterministic)
}
func (m *BgpRouteGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BgpRouteGetRequest.Merge(m, src)
}
func (m *BgpRouteGetRequest) XXX_Size() int {
	return xxx_messageInfo_BgpRouteGetRequest.Size(m)
}
func (m *BgpRouteGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BgpRouteGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BgpRouteGetRequest proto.InternalMessageInfo

func (m *BgpRouteGetRequest) GetBgpRoute() *BgpRouteMatch {
	if m != nil {
		return m.BgpRoute
	}
	return nil
}

func (m *BgpRouteGetRequest) GetOrLonger() bool {
	if m != nil {
		return m.OrLonger
	}
	return false
}

func (m *BgpRouteGetRequest) GetActiveOnly() bool {
	if m != nil {
		return m.ActiveOnly
	}
	return false
}

func (m *BgpRouteGetRequest) GetReplyAddressFormat() jnx_addr.AddressFormat {
	if m != nil {
		return m.ReplyAddressFormat
	}
	return jnx_addr.AddressFormat_ADDRESS_STRING
}

func (m *BgpRouteGetRequest) GetReplyTableFormat() RouteTableFormat {
	if m != nil {
		return m.ReplyTableFormat
	}
	return RouteTableFormat_TABLE_STRING
}

func (m *BgpRouteGetRequest) GetRouteCount() uint32 {
	if m != nil {
		return m.RouteCount
	}
	return 0
}

//*
// Route operation reply containing the status of the operation.
// Replies always returns the final status (either success or the first error
// encountered) and the number of routes that were successfully processed
// prior to any error or full completion of the request.
type BgpRouteOperReply struct {
	//* The final return code for the request.
	Status BgpRouteOperReply_BgpRouteOperStatus `protobuf:"varint,1,opt,name=status,proto3,enum=routing.BgpRouteOperReply_BgpRouteOperStatus" json:"status,omitempty"`
	//* The number of requested operations for which the operation
	// completed successfully. Note that in the case of remove
	// operations with or_longer=TRUE or cookie=0, this is not the number of
	// routes matched and removed.
	OperationsCompleted  uint32   `protobuf:"varint,2,opt,name=operations_completed,json=operationsCompleted,proto3" json:"operations_completed,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BgpRouteOperReply) Reset()         { *m = BgpRouteOperReply{} }
func (m *BgpRouteOperReply) String() string { return proto.CompactTextString(m) }
func (*BgpRouteOperReply) ProtoMessage()    {}
func (*BgpRouteOperReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa66c5a6e3bedc31, []int{16}
}

func (m *BgpRouteOperReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BgpRouteOperReply.Unmarshal(m, b)
}
func (m *BgpRouteOperReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BgpRouteOperReply.Marshal(b, m, deterministic)
}
func (m *BgpRouteOperReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BgpRouteOperReply.Merge(m, src)
}
func (m *BgpRouteOperReply) XXX_Size() int {
	return xxx_messageInfo_BgpRouteOperReply.Size(m)
}
func (m *BgpRouteOperReply) XXX_DiscardUnknown() {
	xxx_messageInfo_BgpRouteOperReply.DiscardUnknown(m)
}

var xxx_messageInfo_BgpRouteOperReply proto.InternalMessageInfo

func (m *BgpRouteOperReply) GetStatus() BgpRouteOperReply_BgpRouteOperStatus {
	if m != nil {
		return m.Status
	}
	return BgpRouteOperReply_SUCCESS
}

func (m *BgpRouteOperReply) GetOperationsCompleted() uint32 {
	if m != nil {
		return m.OperationsCompleted
	}
	return 0
}

//*
// Route get reply containing the status of the operation and the full or
// partial set of matching routes, depending on how many reply RPCs the
// stream of routes is split among.
type BgpRouteGetReply struct {
	//* The final return code for the request.
	Status BgpRouteGetReply_BgpRouteGetStatus `protobuf:"varint,1,opt,name=status,proto3,enum=routing.BgpRouteGetReply_BgpRouteGetStatus" json:"status,omitempty"`
	//* One or more matching bgp routes.
	BgpRoutes            []*BgpRouteEntry `protobuf:"bytes,2,rep,name=bgp_routes,json=bgpRoutes,proto3" json:"bgp_routes,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *BgpRouteGetReply) Reset()         { *m = BgpRouteGetReply{} }
func (m *BgpRouteGetReply) String() string { return proto.CompactTextString(m) }
func (*BgpRouteGetReply) ProtoMessage()    {}
func (*BgpRouteGetReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa66c5a6e3bedc31, []int{17}
}

func (m *BgpRouteGetReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BgpRouteGetReply.Unmarshal(m, b)
}
func (m *BgpRouteGetReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BgpRouteGetReply.Marshal(b, m, deterministic)
}
func (m *BgpRouteGetReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BgpRouteGetReply.Merge(m, src)
}
func (m *BgpRouteGetReply) XXX_Size() int {
	return xxx_messageInfo_BgpRouteGetReply.Size(m)
}
func (m *BgpRouteGetReply) XXX_DiscardUnknown() {
	xxx_messageInfo_BgpRouteGetReply.DiscardUnknown(m)
}

var xxx_messageInfo_BgpRouteGetReply proto.InternalMessageInfo

func (m *BgpRouteGetReply) GetStatus() BgpRouteGetReply_BgpRouteGetStatus {
	if m != nil {
		return m.Status
	}
	return BgpRouteGetReply_SUCCESS
}

func (m *BgpRouteGetReply) GetBgpRoutes() []*BgpRouteEntry {
	if m != nil {
		return m.BgpRoutes
	}
	return nil
}

//*
// Route register operation request parameters. Registers the client
// for streaming route monitoring.
type BgpRouteMonitorRegisterRequest struct {
	//*
	//  The format for IP addresses in the replies to this request.
	//  Optional (default is string)
	ReplyAddressFormat jnx_addr.AddressFormat `protobuf:"varint,1,opt,name=reply_address_format,json=replyAddressFormat,proto3,enum=jnxBase.AddressFormat" json:"reply_address_format,omitempty"`
	//*
	//  The format for IP addresses in the replies to this request.
	//  Optional (default is string)
	ReplyTableFormat RouteTableFormat `protobuf:"varint,2,opt,name=reply_table_format,json=replyTableFormat,proto3,enum=routing.RouteTableFormat" json:"reply_table_format,omitempty"`
	//*
	//  The maximum number of routes requested in each monitoring message.
	//  Replies will be streamed in multiple RPCs each having no more
	//  routes than given by this value. Counts from 1 through the maximum of
	//  1000 may be specified. A value of zero indcates that
	//  the server will choose an appropriate. Optional (default 0)
	RouteCount           uint32   `protobuf:"varint,3,opt,name=route_count,json=routeCount,proto3" json:"route_count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BgpRouteMonitorRegisterRequest) Reset()         { *m = BgpRouteMonitorRegisterRequest{} }
func (m *BgpRouteMonitorRegisterRequest) String() string { return proto.CompactTextString(m) }
func (*BgpRouteMonitorRegisterRequest) ProtoMessage()    {}
func (*BgpRouteMonitorRegisterRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa66c5a6e3bedc31, []int{18}
}

func (m *BgpRouteMonitorRegisterRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BgpRouteMonitorRegisterRequest.Unmarshal(m, b)
}
func (m *BgpRouteMonitorRegisterRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BgpRouteMonitorRegisterRequest.Marshal(b, m, deterministic)
}
func (m *BgpRouteMonitorRegisterRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BgpRouteMonitorRegisterRequest.Merge(m, src)
}
func (m *BgpRouteMonitorRegisterRequest) XXX_Size() int {
	return xxx_messageInfo_BgpRouteMonitorRegisterRequest.Size(m)
}
func (m *BgpRouteMonitorRegisterRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BgpRouteMonitorRegisterRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BgpRouteMonitorRegisterRequest proto.InternalMessageInfo

func (m *BgpRouteMonitorRegisterRequest) GetReplyAddressFormat() jnx_addr.AddressFormat {
	if m != nil {
		return m.ReplyAddressFormat
	}
	return jnx_addr.AddressFormat_ADDRESS_STRING
}

func (m *BgpRouteMonitorRegisterRequest) GetReplyTableFormat() RouteTableFormat {
	if m != nil {
		return m.ReplyTableFormat
	}
	return RouteTableFormat_TABLE_STRING
}

func (m *BgpRouteMonitorRegisterRequest) GetRouteCount() uint32 {
	if m != nil {
		return m.RouteCount
	}
	return 0
}

//*
// The route registration reply is returned immediately upon initial
// registration for route monitoring via a call to BgpRouteMonitorRegister.
// Subsequently, monitoring entries are streamed via replies containing
// route information and status.
type BgpRouteMonitorRegisterReply struct {
	//* The return code for the registration operation.
	Status BgpRouteMonitorRegisterReply_BgpRouteMonitorRegisterStatus `protobuf:"varint,1,opt,name=status,proto3,enum=routing.BgpRouteMonitorRegisterReply_BgpRouteMonitorRegisterStatus" json:"status,omitempty"`
	//*
	//  A set of monitoring entries for individual routes or
	//  the end-of-ribs indication.
	MonitorEntries       []*BgpRouteMonitorEntry `protobuf:"bytes,2,rep,name=monitor_entries,json=monitorEntries,proto3" json:"monitor_entries,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *BgpRouteMonitorRegisterReply) Reset()         { *m = BgpRouteMonitorRegisterReply{} }
func (m *BgpRouteMonitorRegisterReply) String() string { return proto.CompactTextString(m) }
func (*BgpRouteMonitorRegisterReply) ProtoMessage()    {}
func (*BgpRouteMonitorRegisterReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa66c5a6e3bedc31, []int{19}
}

func (m *BgpRouteMonitorRegisterReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BgpRouteMonitorRegisterReply.Unmarshal(m, b)
}
func (m *BgpRouteMonitorRegisterReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BgpRouteMonitorRegisterReply.Marshal(b, m, deterministic)
}
func (m *BgpRouteMonitorRegisterReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BgpRouteMonitorRegisterReply.Merge(m, src)
}
func (m *BgpRouteMonitorRegisterReply) XXX_Size() int {
	return xxx_messageInfo_BgpRouteMonitorRegisterReply.Size(m)
}
func (m *BgpRouteMonitorRegisterReply) XXX_DiscardUnknown() {
	xxx_messageInfo_BgpRouteMonitorRegisterReply.DiscardUnknown(m)
}

var xxx_messageInfo_BgpRouteMonitorRegisterReply proto.InternalMessageInfo

func (m *BgpRouteMonitorRegisterReply) GetStatus() BgpRouteMonitorRegisterReply_BgpRouteMonitorRegisterStatus {
	if m != nil {
		return m.Status
	}
	return BgpRouteMonitorRegisterReply_SUCCESS
}

func (m *BgpRouteMonitorRegisterReply) GetMonitorEntries() []*BgpRouteMonitorEntry {
	if m != nil {
		return m.MonitorEntries
	}
	return nil
}

//*
// Request to unregister the client from the BGP route monitoring.
// No parameters are needed.
type BgpRouteMonitorUnregisterRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BgpRouteMonitorUnregisterRequest) Reset()         { *m = BgpRouteMonitorUnregisterRequest{} }
func (m *BgpRouteMonitorUnregisterRequest) String() string { return proto.CompactTextString(m) }
func (*BgpRouteMonitorUnregisterRequest) ProtoMessage()    {}
func (*BgpRouteMonitorUnregisterRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa66c5a6e3bedc31, []int{20}
}

func (m *BgpRouteMonitorUnregisterRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BgpRouteMonitorUnregisterRequest.Unmarshal(m, b)
}
func (m *BgpRouteMonitorUnregisterRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BgpRouteMonitorUnregisterRequest.Marshal(b, m, deterministic)
}
func (m *BgpRouteMonitorUnregisterRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BgpRouteMonitorUnregisterRequest.Merge(m, src)
}
func (m *BgpRouteMonitorUnregisterRequest) XXX_Size() int {
	return xxx_messageInfo_BgpRouteMonitorUnregisterRequest.Size(m)
}
func (m *BgpRouteMonitorUnregisterRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BgpRouteMonitorUnregisterRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BgpRouteMonitorUnregisterRequest proto.InternalMessageInfo

//*
// The route unregistration reply confirms that the client has
// unregistered for route updates.
type BgpRouteMonitorUnregisterReply struct {
	// The return code for the unregiter operation.
	Status               BgpRouteMonitorUnregisterReply_BgpRouteMonitorUnregisterStatus `protobuf:"varint,1,opt,name=status,proto3,enum=routing.BgpRouteMonitorUnregisterReply_BgpRouteMonitorUnregisterStatus" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                       `json:"-"`
	XXX_unrecognized     []byte                                                         `json:"-"`
	XXX_sizecache        int32                                                          `json:"-"`
}

func (m *BgpRouteMonitorUnregisterReply) Reset()         { *m = BgpRouteMonitorUnregisterReply{} }
func (m *BgpRouteMonitorUnregisterReply) String() string { return proto.CompactTextString(m) }
func (*BgpRouteMonitorUnregisterReply) ProtoMessage()    {}
func (*BgpRouteMonitorUnregisterReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa66c5a6e3bedc31, []int{21}
}

func (m *BgpRouteMonitorUnregisterReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BgpRouteMonitorUnregisterReply.Unmarshal(m, b)
}
func (m *BgpRouteMonitorUnregisterReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BgpRouteMonitorUnregisterReply.Marshal(b, m, deterministic)
}
func (m *BgpRouteMonitorUnregisterReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BgpRouteMonitorUnregisterReply.Merge(m, src)
}
func (m *BgpRouteMonitorUnregisterReply) XXX_Size() int {
	return xxx_messageInfo_BgpRouteMonitorUnregisterReply.Size(m)
}
func (m *BgpRouteMonitorUnregisterReply) XXX_DiscardUnknown() {
	xxx_messageInfo_BgpRouteMonitorUnregisterReply.DiscardUnknown(m)
}

var xxx_messageInfo_BgpRouteMonitorUnregisterReply proto.InternalMessageInfo

func (m *BgpRouteMonitorUnregisterReply) GetStatus() BgpRouteMonitorUnregisterReply_BgpRouteMonitorUnregisterStatus {
	if m != nil {
		return m.Status
	}
	return BgpRouteMonitorUnregisterReply_SUCCESS
}

//*
// Request to refresh all route monitoring entries to the client.
// No parameters are needed.
type BgpRouteMonitorRefreshRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BgpRouteMonitorRefreshRequest) Reset()         { *m = BgpRouteMonitorRefreshRequest{} }
func (m *BgpRouteMonitorRefreshRequest) String() string { return proto.CompactTextString(m) }
func (*BgpRouteMonitorRefreshRequest) ProtoMessage()    {}
func (*BgpRouteMonitorRefreshRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa66c5a6e3bedc31, []int{22}
}

func (m *BgpRouteMonitorRefreshRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BgpRouteMonitorRefreshRequest.Unmarshal(m, b)
}
func (m *BgpRouteMonitorRefreshRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BgpRouteMonitorRefreshRequest.Marshal(b, m, deterministic)
}
func (m *BgpRouteMonitorRefreshRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BgpRouteMonitorRefreshRequest.Merge(m, src)
}
func (m *BgpRouteMonitorRefreshRequest) XXX_Size() int {
	return xxx_messageInfo_BgpRouteMonitorRefreshRequest.Size(m)
}
func (m *BgpRouteMonitorRefreshRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BgpRouteMonitorRefreshRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BgpRouteMonitorRefreshRequest proto.InternalMessageInfo

//*
// The route Refresh reply confirms that the client has
// triggered a refresh of route monitoring entries, which
// will be delivered followed by End-of-RIBs via the
// BgpRouteMonitorRegisterReply stream.
type BgpRouteMonitorRefreshReply struct {
	// The return code for the refresh operation.
	Status               BgpRouteMonitorRefreshReply_BgpRouteMonitorRefreshStatus `protobuf:"varint,1,opt,name=status,proto3,enum=routing.BgpRouteMonitorRefreshReply_BgpRouteMonitorRefreshStatus" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                 `json:"-"`
	XXX_unrecognized     []byte                                                   `json:"-"`
	XXX_sizecache        int32                                                    `json:"-"`
}

func (m *BgpRouteMonitorRefreshReply) Reset()         { *m = BgpRouteMonitorRefreshReply{} }
func (m *BgpRouteMonitorRefreshReply) String() string { return proto.CompactTextString(m) }
func (*BgpRouteMonitorRefreshReply) ProtoMessage()    {}
func (*BgpRouteMonitorRefreshReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa66c5a6e3bedc31, []int{23}
}

func (m *BgpRouteMonitorRefreshReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BgpRouteMonitorRefreshReply.Unmarshal(m, b)
}
func (m *BgpRouteMonitorRefreshReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BgpRouteMonitorRefreshReply.Marshal(b, m, deterministic)
}
func (m *BgpRouteMonitorRefreshReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BgpRouteMonitorRefreshReply.Merge(m, src)
}
func (m *BgpRouteMonitorRefreshReply) XXX_Size() int {
	return xxx_messageInfo_BgpRouteMonitorRefreshReply.Size(m)
}
func (m *BgpRouteMonitorRefreshReply) XXX_DiscardUnknown() {
	xxx_messageInfo_BgpRouteMonitorRefreshReply.DiscardUnknown(m)
}

var xxx_messageInfo_BgpRouteMonitorRefreshReply proto.InternalMessageInfo

func (m *BgpRouteMonitorRefreshReply) GetStatus() BgpRouteMonitorRefreshReply_BgpRouteMonitorRefreshStatus {
	if m != nil {
		return m.Status
	}
	return BgpRouteMonitorRefreshReply_SUCCESS
}

func init() {
	proto.RegisterEnum("routing.RouteProtocol", RouteProtocol_name, RouteProtocol_value)
	proto.RegisterEnum("routing.RouteOperation", RouteOperation_name, RouteOperation_value)
	proto.RegisterEnum("routing.BgpPeerType", BgpPeerType_name, BgpPeerType_value)
	proto.RegisterEnum("routing.BgpRouteMonitorEntry_BgpRouteMonitorOper", BgpRouteMonitorEntry_BgpRouteMonitorOper_name, BgpRouteMonitorEntry_BgpRouteMonitorOper_value)
	proto.RegisterEnum("routing.BgpRouteInitializeReply_BgpRouteInitializeStatus", BgpRouteInitializeReply_BgpRouteInitializeStatus_name, BgpRouteInitializeReply_BgpRouteInitializeStatus_value)
	proto.RegisterEnum("routing.BgpRouteCleanupReply_BgpRouteCleanupStatus", BgpRouteCleanupReply_BgpRouteCleanupStatus_name, BgpRouteCleanupReply_BgpRouteCleanupStatus_value)
	proto.RegisterEnum("routing.BgpRouteOperReply_BgpRouteOperStatus", BgpRouteOperReply_BgpRouteOperStatus_name, BgpRouteOperReply_BgpRouteOperStatus_value)
	proto.RegisterEnum("routing.BgpRouteGetReply_BgpRouteGetStatus", BgpRouteGetReply_BgpRouteGetStatus_name, BgpRouteGetReply_BgpRouteGetStatus_value)
	proto.RegisterEnum("routing.BgpRouteMonitorRegisterReply_BgpRouteMonitorRegisterStatus", BgpRouteMonitorRegisterReply_BgpRouteMonitorRegisterStatus_name, BgpRouteMonitorRegisterReply_BgpRouteMonitorRegisterStatus_value)
	proto.RegisterEnum("routing.BgpRouteMonitorUnregisterReply_BgpRouteMonitorUnregisterStatus", BgpRouteMonitorUnregisterReply_BgpRouteMonitorUnregisterStatus_name, BgpRouteMonitorUnregisterReply_BgpRouteMonitorUnregisterStatus_value)
	proto.RegisterEnum("routing.BgpRouteMonitorRefreshReply_BgpRouteMonitorRefreshStatus", BgpRouteMonitorRefreshReply_BgpRouteMonitorRefreshStatus_name, BgpRouteMonitorRefreshReply_BgpRouteMonitorRefreshStatus_value)
	proto.RegisterType((*BgpRouteOperationFlags)(nil), "routing.BgpRouteOperationFlags")
	proto.RegisterType((*BgpAttrib32)(nil), "routing.BgpAttrib32")
	proto.RegisterType((*BgpAttrib64)(nil), "routing.BgpAttrib64")
	proto.RegisterType((*Community)(nil), "routing.Community")
	proto.RegisterType((*CommunityList)(nil), "routing.CommunityList")
	proto.RegisterType((*AsPath)(nil), "routing.AsPath")
	proto.RegisterType((*BgpRouteMatch)(nil), "routing.BgpRouteMatch")
	proto.RegisterType((*BgpRouteEntry)(nil), "routing.BgpRouteEntry")
	proto.RegisterType((*BgpRouteMonitorEntry)(nil), "routing.BgpRouteMonitorEntry")
	proto.RegisterType((*BgpRouteInitializeRequest)(nil), "routing.BgpRouteInitializeRequest")
	proto.RegisterType((*BgpRouteInitializeReply)(nil), "routing.BgpRouteInitializeReply")
	proto.RegisterType((*BgpRouteCleanupRequest)(nil), "routing.BgpRouteCleanupRequest")
	proto.RegisterType((*BgpRouteCleanupReply)(nil), "routing.BgpRouteCleanupReply")
	proto.RegisterType((*BgpRouteUpdateRequest)(nil), "routing.BgpRouteUpdateRequest")
	proto.RegisterType((*BgpRouteRemoveRequest)(nil), "routing.BgpRouteRemoveRequest")
	proto.RegisterType((*BgpRouteGetRequest)(nil), "routing.BgpRouteGetRequest")
	proto.RegisterType((*BgpRouteOperReply)(nil), "routing.BgpRouteOperReply")
	proto.RegisterType((*BgpRouteGetReply)(nil), "routing.BgpRouteGetReply")
	proto.RegisterType((*BgpRouteMonitorRegisterRequest)(nil), "routing.BgpRouteMonitorRegisterRequest")
	proto.RegisterType((*BgpRouteMonitorRegisterReply)(nil), "routing.BgpRouteMonitorRegisterReply")
	proto.RegisterType((*BgpRouteMonitorUnregisterRequest)(nil), "routing.BgpRouteMonitorUnregisterRequest")
	proto.RegisterType((*BgpRouteMonitorUnregisterReply)(nil), "routing.BgpRouteMonitorUnregisterReply")
	proto.RegisterType((*BgpRouteMonitorRefreshRequest)(nil), "routing.BgpRouteMonitorRefreshRequest")
	proto.RegisterType((*BgpRouteMonitorRefreshReply)(nil), "routing.BgpRouteMonitorRefreshReply")
}

func init() { proto.RegisterFile("bgp_route_service.proto", fileDescriptor_fa66c5a6e3bedc31) }

var fileDescriptor_fa66c5a6e3bedc31 = []byte{
	// 2320 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x58, 0x4b, 0x73, 0xdb, 0xc8,
	0x11, 0x16, 0xa9, 0x17, 0xd9, 0x14, 0x25, 0x68, 0xf4, 0x30, 0x2d, 0xad, 0x2d, 0x05, 0x9b, 0xec,
	0xc3, 0x89, 0x5d, 0xb1, 0xbc, 0xeb, 0x64, 0x2f, 0xd9, 0x40, 0xe4, 0x88, 0xc2, 0x9a, 0x02, 0xb8,
	0x03, 0xd0, 0x91, 0x92, 0x54, 0x4d, 0x41, 0xe4, 0x88, 0x82, 0x4d, 0x02, 0x5c, 0x00, 0xd2, 0x5a,
	0xf9, 0x01, 0x7b, 0xcf, 0x1f, 0xc8, 0x39, 0x87, 0x9c, 0x72, 0xdd, 0x9f, 0x91, 0x1c, 0x72, 0x4d,
	0x2a, 0x87, 0x9c, 0x72, 0xcc, 0x39, 0x35, 0x83, 0x17, 0x01, 0x92, 0xb2, 0xca, 0xf1, 0x29, 0x37,
	0xa2, 0xfb, 0xeb, 0xee, 0x99, 0x9e, 0xee, 0x6f, 0x7a, 0x08, 0xf7, 0xce, 0xfb, 0x23, 0xea, 0xb9,
	0x57, 0x01, 0xa3, 0x3e, 0xf3, 0xae, 0xed, 0x2e, 0x7b, 0x32, 0xf2, 0xdc, 0xc0, 0x45, 0xcb, 0x5c,
	0x68, 0x3b, 0xfd, 0x9d, 0xd5, 0x57, 0xce, 0x1b, 0x6a, 0xf5, 0x7a, 0x5e, 0xa8, 0xd8, 0x59, 0x1f,
	0x79, 0xa3, 0x1e, 0xed, 0xba, 0xc3, 0xa1, 0xeb, 0x84, 0x22, 0xf9, 0xbb, 0x02, 0x6c, 0x1f, 0xf6,
	0x47, 0x84, 0xbb, 0xd1, 0x47, 0xcc, 0xb3, 0x02, 0xdb, 0x75, 0x8e, 0x06, 0x56, 0xdf, 0x47, 0x3f,
	0x80, 0x15, 0xc7, 0xa5, 0x56, 0xef, 0x9a, 0x79, 0x81, 0xed, 0xb3, 0x5a, 0x61, 0xbf, 0xf0, 0x49,
	0x89, 0x54, 0x1c, 0x57, 0x89, 0x45, 0x68, 0x17, 0xca, 0x8e, 0x4b, 0xd9, 0x9b, 0x91, 0xeb, 0x05,
	0xb5, 0xa2, 0xd0, 0x97, 0x1c, 0x17, 0x8b, 0x6f, 0xf4, 0x13, 0x40, 0x57, 0x3e, 0xa3, 0x0e, 0x7b,
	0x13, 0x5c, 0xba, 0x23, 0xea, 0xb1, 0x57, 0xac, 0x1b, 0xd4, 0xe6, 0x05, 0x4a, 0xba, 0xf2, 0x99,
	0x16, 0x2a, 0x88, 0x90, 0xcb, 0x1f, 0x42, 0xe5, 0xb0, 0x3f, 0x52, 0x82, 0xc0, 0xb3, 0xcf, 0x9f,
	0x1d, 0xa0, 0x4d, 0x58, 0xbc, 0xb6, 0x06, 0x57, 0x61, 0xd4, 0x2a, 0x09, 0x3f, 0x32, 0xa0, 0xe7,
	0x9f, 0x65, 0x41, 0x0b, 0x31, 0xe8, 0x39, 0x94, 0xeb, 0xee, 0x70, 0x78, 0xe5, 0xd8, 0xc1, 0x0d,
	0xfa, 0x14, 0xa4, 0x6e, 0xfc, 0x41, 0xfd, 0xc0, 0xb3, 0x9d, 0xbe, 0x40, 0x97, 0xc9, 0x5a, 0x22,
	0x37, 0x84, 0x58, 0xfe, 0x05, 0x54, 0x13, 0xbb, 0x96, 0xed, 0x07, 0xe8, 0x31, 0x94, 0xba, 0xee,
	0x90, 0x0e, 0x6c, 0x3f, 0xa8, 0x15, 0xf6, 0xe7, 0x3f, 0xa9, 0x1c, 0xa0, 0x27, 0x51, 0x6a, 0x9f,
	0x24, 0x48, 0xb2, 0xdc, 0x75, 0x87, 0x1c, 0x2e, 0x3f, 0x86, 0x25, 0xc5, 0x6f, 0x5b, 0xc1, 0x25,
	0xfa, 0x10, 0xaa, 0x96, 0x3f, 0xb2, 0x82, 0xcb, 0x6c, 0xc4, 0x95, 0x50, 0x18, 0x85, 0xfb, 0x63,
	0x11, 0xaa, 0x71, 0xe6, 0x4f, 0xac, 0xa0, 0x7b, 0x89, 0x3e, 0x87, 0x4a, 0x8f, 0xf9, 0x01, 0x1d,
	0x79, 0xec, 0xc2, 0x7e, 0x23, 0x8c, 0x2a, 0x07, 0x9b, 0x49, 0x48, 0x81, 0x6c, 0x0b, 0x1d, 0x01,
	0x0e, 0x0c, 0x7f, 0xa3, 0x8f, 0x60, 0x6d, 0xcc, 0x8c, 0x0e, 0x98, 0x23, 0x8e, 0xa2, 0x4a, 0xaa,
	0x29, 0xa8, 0xc5, 0x1c, 0xf4, 0x29, 0x2c, 0x06, 0xd6, 0xf9, 0x80, 0x89, 0x23, 0xa8, 0x1c, 0x6c,
	0x64, 0x1d, 0x9b, 0x5c, 0x45, 0x42, 0x04, 0x3a, 0x80, 0x92, 0x28, 0x8f, 0xae, 0x3b, 0xa8, 0x2d,
	0xec, 0x17, 0x3e, 0x59, 0x3d, 0xd8, 0xce, 0x2f, 0x23, 0xd4, 0x92, 0x04, 0x87, 0xf6, 0xa0, 0x22,
	0xb6, 0xdc, 0x75, 0xdd, 0xd7, 0x36, 0xab, 0x2d, 0x8a, 0x23, 0x01, 0x2e, 0xaa, 0x0b, 0x09, 0xfa,
	0x39, 0x54, 0xe2, 0x94, 0xdb, 0xcc, 0xaf, 0x2d, 0x89, 0x55, 0x6c, 0x4f, 0x66, 0x94, 0x27, 0x93,
	0x8c, 0x43, 0xe5, 0xbf, 0x97, 0xd2, 0x54, 0x61, 0x27, 0xf0, 0x6e, 0xfe, 0xdf, 0x53, 0xf5, 0x25,
	0x48, 0x61, 0x63, 0xf3, 0x85, 0x32, 0x8f, 0x39, 0x5d, 0x16, 0xe5, 0x2b, 0xdd, 0xe3, 0x58, 0xb7,
	0x90, 0x35, 0x2f, 0xde, 0x70, 0x08, 0xe6, 0x0e, 0x06, 0x6e, 0xd7, 0x1a, 0x8c, 0x3b, 0x58, 0xbe,
	0xcd, 0x81, 0x40, 0x8f, 0x39, 0xf8, 0x08, 0xe6, 0x87, 0xac, 0x57, 0x2b, 0xdd, 0x62, 0xc3, 0x01,
	0xe8, 0x0b, 0xa8, 0x5a, 0x76, 0x7f, 0x44, 0x7b, 0xb6, 0x1f, 0x58, 0x3c, 0x4a, 0x79, 0x96, 0xc5,
	0xf3, 0xcf, 0xc8, 0x0a, 0x87, 0x36, 0x22, 0x24, 0x7a, 0x00, 0xe5, 0xeb, 0x91, 0x43, 0x07, 0xd6,
	0x39, 0x1b, 0xd4, 0x80, 0x1f, 0xc3, 0xf1, 0x1c, 0x29, 0x5d, 0x8f, 0x9c, 0x16, 0x97, 0xa0, 0xc7,
	0xb0, 0x24, 0x54, 0x7e, 0xad, 0x92, 0x3b, 0x04, 0xa1, 0x37, 0x02, 0xab, 0xfb, 0xfa, 0x78, 0x8e,
	0x44, 0xa0, 0x7c, 0x75, 0xad, 0xdc, 0xb9, 0xba, 0xd0, 0xc7, 0xb0, 0x14, 0x36, 0x66, 0xad, 0x2a,
	0x8c, 0xd6, 0x12, 0xa3, 0xb0, 0x9d, 0x49, 0xa4, 0xe6, 0x7b, 0x75, 0x3d, 0xbb, 0x6f, 0x3b, 0x56,
	0xe0, 0x7a, 0xd4, 0xee, 0xd5, 0x56, 0x6f, 0xc9, 0xce, 0x4a, 0x0a, 0x55, 0x7b, 0xe8, 0x67, 0xb0,
	0xd2, 0x1d, 0x5c, 0xf9, 0x01, 0xf3, 0x42, 0x3a, 0x59, 0x13, 0x74, 0x32, 0xdd, 0xb2, 0x12, 0x21,
	0x05, 0x07, 0x3d, 0x03, 0x88, 0x0d, 0xed, 0x5e, 0x4d, 0xba, 0x25, 0x60, 0x39, 0xc2, 0xa9, 0x3d,
	0xf4, 0x08, 0xc2, 0x82, 0xa0, 0xee, 0x88, 0x79, 0xf4, 0x62, 0x60, 0xf5, 0x6b, 0xeb, 0x3c, 0xbf,
	0x87, 0xc5, 0x5a, 0x81, 0x54, 0xbd, 0x98, 0xeb, 0x39, 0xcd, 0xa3, 0x2f, 0x61, 0x3d, 0xae, 0xcb,
	0x98, 0xaa, 0xfd, 0x1a, 0x8a, 0xd8, 0xee, 0x95, 0xf3, 0xe6, 0xd0, 0xf2, 0xd9, 0x13, 0x75, 0xa4,
	0xf4, 0x7a, 0x1e, 0xf3, 0x7d, 0x22, 0xc5, 0xe0, 0x88, 0xbd, 0x7d, 0xbe, 0xc2, 0x30, 0x58, 0x70,
	0x33, 0x62, 0xb5, 0x0d, 0xd1, 0x02, 0x99, 0x15, 0xb6, 0x19, 0xf3, 0xcc, 0x9b, 0x11, 0x23, 0x65,
	0x81, 0xe3, 0x3f, 0xd1, 0x2f, 0xa1, 0x12, 0x1a, 0xf1, 0xc5, 0xf9, 0xb5, 0x4d, 0xb1, 0xaf, 0xbd,
	0x71, 0xab, 0x29, 0x37, 0x12, 0x09, 0x03, 0x85, 0xb7, 0x93, 0x12, 0x87, 0xed, 0x59, 0x81, 0x55,
	0xdb, 0x12, 0x0e, 0xe4, 0xf4, 0xe4, 0xc2, 0xe5, 0x1e, 0x59, 0x43, 0x7b, 0x70, 0x63, 0x8c, 0x58,
	0xd7, 0xbe, 0xb0, 0xbb, 0x0d, 0x2b, 0xb0, 0xa2, 0x45, 0xf0, 0x9f, 0x87, 0x15, 0x28, 0x8b, 0x52,
	0x52, 0x9d, 0x0b, 0x57, 0xfe, 0x57, 0x01, 0x36, 0x13, 0x3a, 0x76, 0x1d, 0x3b, 0x70, 0xbd, 0x90,
	0x6a, 0x74, 0x28, 0xbb, 0xf1, 0x32, 0x04, 0xd1, 0xac, 0x1e, 0x3c, 0x9d, 0x58, 0xe8, 0xb8, 0x45,
	0x5e, 0xc8, 0x37, 0x41, 0x52, 0x1f, 0xe8, 0x19, 0x94, 0x93, 0x9b, 0x5b, 0xd0, 0xcf, 0x78, 0x9d,
	0x66, 0x68, 0x8e, 0x94, 0xce, 0xa3, 0x4f, 0xf9, 0x2b, 0xd8, 0x98, 0xe2, 0x16, 0x49, 0xb0, 0x42,
	0xf4, 0x8e, 0x89, 0x69, 0xa7, 0xdd, 0x50, 0x4c, 0x2c, 0xcd, 0xa5, 0x12, 0x82, 0x4f, 0xf4, 0x97,
	0x58, 0x2a, 0xa0, 0x35, 0xa8, 0x60, 0xad, 0x41, 0xf5, 0x23, 0x4a, 0xd4, 0x43, 0x43, 0x2a, 0xca,
	0xbb, 0x70, 0x3f, 0xf6, 0xa5, 0xf2, 0x1e, 0xb0, 0x06, 0xf6, 0xef, 0x18, 0x61, 0xdf, 0x5c, 0x31,
	0x3f, 0x90, 0xbf, 0x2f, 0xc2, 0xbd, 0x69, 0xda, 0xd1, 0xe0, 0x06, 0x7d, 0x0d, 0x4b, 0x7e, 0x60,
	0x05, 0x57, 0x7e, 0x94, 0x87, 0x2f, 0x26, 0x96, 0x9d, 0xb3, 0x98, 0x22, 0x37, 0x84, 0x03, 0x12,
	0x39, 0x42, 0x0f, 0xa1, 0xd2, 0xff, 0x96, 0x3a, 0x61, 0x36, 0xfc, 0x88, 0x8d, 0xcb, 0xfd, 0x6f,
	0x35, 0x61, 0xe6, 0xcb, 0x7f, 0x2a, 0x40, 0x6d, 0x96, 0x13, 0x54, 0x81, 0x65, 0xa3, 0x53, 0xaf,
	0x63, 0xc3, 0x90, 0xe6, 0xd0, 0x7d, 0xd8, 0x8a, 0x3e, 0xa8, 0x61, 0x2a, 0x22, 0x01, 0x87, 0x7a,
	0x47, 0x6b, 0x48, 0x05, 0x84, 0x60, 0x55, 0xd5, 0x4c, 0x4c, 0x34, 0xa5, 0x45, 0x31, 0x21, 0x3a,
	0x91, 0x8a, 0xe8, 0x1e, 0x6c, 0x28, 0x2d, 0x82, 0x95, 0xc6, 0x19, 0x55, 0x35, 0xd5, 0x54, 0x95,
	0x96, 0xfa, 0x6b, 0xdc, 0x90, 0xe6, 0xd1, 0x06, 0xac, 0x35, 0x15, 0x13, 0xff, 0x4a, 0xe1, 0x8a,
	0x97, 0x4a, 0x4b, 0x6d, 0x48, 0x0b, 0x5c, 0x58, 0x6f, 0x61, 0x45, 0xeb, 0xb4, 0x69, 0x1b, 0x6b,
	0x0d, 0x55, 0x6b, 0x4a, 0x8b, 0x68, 0x1d, 0xaa, 0x87, 0xcd, 0x36, 0xd5, 0x74, 0x93, 0x0a, 0x47,
	0xd2, 0x92, 0x5c, 0x4b, 0xa7, 0xa9, 0xfa, 0x80, 0x59, 0xce, 0xd5, 0x28, 0xce, 0xeb, 0x9f, 0xc7,
	0xea, 0x2b, 0x51, 0xf1, 0xa4, 0xbe, 0xc8, 0x25, 0xf5, 0xd9, 0x44, 0x52, 0xc7, 0xe1, 0x79, 0x61,
	0x36, 0x9d, 0xf2, 0x09, 0x6c, 0x4d, 0x05, 0x64, 0x53, 0x35, 0x99, 0x8f, 0x02, 0xdf, 0x21, 0xdf,
	0xc8, 0x78, 0x2e, 0x8a, 0xb2, 0x96, 0xba, 0xeb, 0x8c, 0x7a, 0x56, 0x10, 0x57, 0x09, 0xfa, 0x1c,
	0x20, 0xa9, 0x61, 0x3f, 0x1a, 0x8e, 0x66, 0x15, 0x71, 0x39, 0x2e, 0x62, 0x5f, 0x7e, 0x9d, 0xfa,
	0x23, 0x6c, 0xe8, 0x5e, 0x27, 0xfe, 0x76, 0xa1, 0xec, 0x7a, 0x74, 0xe0, 0x3a, 0x7d, 0xe6, 0x45,
	0x83, 0x66, 0xc9, 0xf5, 0x5a, 0xe2, 0x3b, 0x17, 0xac, 0x38, 0x23, 0x98, 0x98, 0xa1, 0xc6, 0x83,
	0x7d, 0x5f, 0x04, 0x14, 0x2b, 0x9b, 0x2c, 0x88, 0x43, 0x65, 0xda, 0xaf, 0x30, 0xa3, 0xfd, 0x42,
	0x67, 0x49, 0xfb, 0x65, 0xd7, 0x57, 0xcc, 0xad, 0x6f, 0x0f, 0x2a, 0x56, 0x37, 0xb0, 0xaf, 0x19,
	0x75, 0x9d, 0xc1, 0x4d, 0x34, 0xe1, 0x42, 0x28, 0xd2, 0x9d, 0xc1, 0x0d, 0x3a, 0x86, 0x4d, 0x8f,
	0x1f, 0x9e, 0x98, 0xc5, 0x99, 0xef, 0xd3, 0x0b, 0xd7, 0x1b, 0x5a, 0x41, 0x32, 0x2f, 0xc4, 0x34,
	0x1b, 0xb3, 0x96, 0xd0, 0x12, 0x24, 0x6c, 0x32, 0x32, 0xd4, 0x84, 0x50, 0x4a, 0xc5, 0xf0, 0x11,
	0xfb, 0x59, 0x14, 0x7e, 0xee, 0x4f, 0x99, 0x52, 0x22, 0x57, 0x92, 0x30, 0x1a, 0x93, 0xf0, 0x35,
	0x87, 0xf4, 0xd9, 0x75, 0xaf, 0x9c, 0x40, 0x0c, 0x17, 0xd5, 0x88, 0x5f, 0xeb, 0x5c, 0x22, 0x7f,
	0xb7, 0x0c, 0xeb, 0xe3, 0x34, 0x1c, 0x16, 0x2b, 0xce, 0x15, 0xeb, 0xe3, 0xa9, 0x94, 0x9d, 0xad,
	0x54, 0x2e, 0xc9, 0x75, 0xfd, 0x53, 0xd8, 0x4c, 0xf8, 0xd0, 0xe7, 0x0f, 0x92, 0xd1, 0x80, 0x05,
	0xac, 0x17, 0xb5, 0xff, 0x46, 0xaa, 0xab, 0xc7, 0x2a, 0xf9, 0x3f, 0x8b, 0xe9, 0x69, 0xa6, 0x1e,
	0xdf, 0xad, 0xae, 0x51, 0x19, 0x16, 0x35, 0x9d, 0xea, 0x6d, 0x69, 0x9e, 0xf3, 0xa5, 0xa9, 0xeb,
	0xf4, 0x44, 0xd1, 0xce, 0xa8, 0xde, 0x36, 0xa4, 0x05, 0xde, 0xd6, 0xa6, 0x72, 0xd8, 0xc2, 0x49,
	0xfb, 0x2f, 0x72, 0x27, 0xa1, 0x68, 0xac, 0xd7, 0x79, 0xb4, 0x36, 0xc1, 0x47, 0xea, 0x69, 0x02,
	0x5c, 0x46, 0x35, 0xd8, 0x8c, 0x64, 0x2d, 0xac, 0x51, 0xee, 0xd8, 0x38, 0xd6, 0x89, 0x29, 0x95,
	0x38, 0xdf, 0xe4, 0x34, 0x2d, 0x5d, 0x6b, 0x4a, 0xe5, 0x69, 0x7c, 0x03, 0x62, 0xd5, 0xf8, 0xd4,
	0x3c, 0xd6, 0xdb, 0x89, 0xb0, 0x82, 0x76, 0xe1, 0x5e, 0x2c, 0x54, 0x1a, 0x0d, 0xc2, 0x99, 0x2e,
	0x56, 0xae, 0xa0, 0x6d, 0x40, 0xb1, 0x12, 0xd7, 0x4f, 0xda, 0xb4, 0xa5, 0x9e, 0xa8, 0xa6, 0x54,
	0x45, 0x3b, 0xb0, 0x5d, 0xd7, 0x4f, 0x4e, 0x3a, 0x9a, 0x6a, 0x9e, 0xd1, 0x96, 0x6a, 0x98, 0x89,
	0xcd, 0x2a, 0xdf, 0x81, 0x62, 0xb4, 0x15, 0xf3, 0x38, 0x91, 0xad, 0x71, 0x3f, 0x2d, 0xe5, 0x10,
	0xb7, 0xa8, 0xaa, 0x1d, 0xe9, 0x89, 0x5c, 0x4a, 0xef, 0x15, 0x7c, 0xaa, 0x1a, 0xa6, 0x21, 0xad,
	0xf3, 0x35, 0x86, 0x12, 0x9e, 0x94, 0x23, 0x41, 0xb5, 0x88, 0x27, 0xa0, 0xde, 0xea, 0x18, 0x26,
	0x26, 0xd9, 0x60, 0x1b, 0x68, 0x13, 0xa4, 0x36, 0xd1, 0x4d, 0xbd, 0xae, 0xb7, 0x12, 0xe9, 0x26,
	0x97, 0x86, 0x4e, 0x94, 0x46, 0x83, 0x1e, 0x29, 0x6a, 0x0b, 0x37, 0xa4, 0xad, 0x49, 0x66, 0xdd,
	0x46, 0x55, 0x28, 0x9b, 0xe4, 0x8c, 0x2a, 0x4d, 0x45, 0xd5, 0xa4, 0x7b, 0x3c, 0x9d, 0x04, 0x7f,
	0xdd, 0xc1, 0x86, 0x49, 0x3b, 0x9a, 0xd1, 0x69, 0xb7, 0x75, 0x62, 0xe2, 0x86, 0x54, 0x43, 0x5b,
	0xb0, 0xde, 0xc6, 0x98, 0x50, 0xf3, 0xac, 0x9d, 0x9e, 0xe0, 0x7d, 0xbe, 0x2e, 0x03, 0x37, 0x4f,
	0xb0, 0x66, 0x66, 0xd7, 0xb5, 0xc3, 0xb7, 0x11, 0x6b, 0x62, 0xe1, 0xae, 0xb8, 0x4c, 0x62, 0x78,
	0x94, 0x8d, 0x50, 0xf5, 0x01, 0x4f, 0x50, 0x82, 0x6f, 0x24, 0xf2, 0x07, 0xe8, 0x21, 0xec, 0x64,
	0x22, 0xd4, 0xf5, 0xce, 0x98, 0xcb, 0x87, 0xe3, 0x2e, 0xb3, 0xaa, 0x3d, 0x7e, 0xb0, 0x06, 0xe1,
	0x37, 0x96, 0xc8, 0x44, 0x43, 0x31, 0x95, 0x44, 0xb9, 0x2f, 0xff, 0x73, 0x1e, 0xa4, 0x0c, 0x8d,
	0xf1, 0x3e, 0xac, 0xe7, 0xfa, 0xf0, 0xc7, 0x13, 0x7d, 0x18, 0x43, 0xc7, 0x05, 0xb9, 0x2e, 0xbc,
	0x1b, 0xaf, 0x4e, 0x90, 0xf8, 0x5f, 0x8a, 0x29, 0x33, 0x24, 0x4e, 0xdf, 0xb1, 0x11, 0x27, 0x7a,
	0x6d, 0x7e, 0x5a, 0xaf, 0x2d, 0x4c, 0xe9, 0xb5, 0xc5, 0x99, 0xbd, 0xb6, 0x34, 0xab, 0xd7, 0x96,
	0xa7, 0x95, 0x6c, 0x69, 0x6a, 0x61, 0x96, 0xf9, 0xca, 0x42, 0x68, 0xda, 0x94, 0x33, 0x6a, 0xae,
	0x92, 0xad, 0xcd, 0x15, 0x81, 0x13, 0xa6, 0xd9, 0x73, 0xbe, 0xb5, 0x17, 0xe5, 0xbf, 0x16, 0xe0,
	0x61, 0x6e, 0xc2, 0x23, 0xac, 0x6f, 0xf3, 0x89, 0x3e, 0xbe, 0xb9, 0x66, 0x5d, 0x23, 0x85, 0xf7,
	0x74, 0x8d, 0x14, 0xff, 0xe7, 0x6b, 0x64, 0x7e, 0xe2, 0x1a, 0xf9, 0xc3, 0x3c, 0x7c, 0x30, 0x73,
	0x5b, 0xbc, 0x92, 0x7f, 0x93, 0xab, 0xe4, 0xfa, 0xac, 0xd9, 0x3a, 0x63, 0x36, 0x4b, 0x99, 0xab,
	0xf0, 0x23, 0x58, 0x1b, 0x86, 0x00, 0xca, 0x9c, 0xc0, 0xb3, 0x93, 0x32, 0x7f, 0x70, 0xeb, 0x04,
	0x4f, 0x56, 0x87, 0xe9, 0x97, 0xcd, 0x7c, 0xf9, 0x6f, 0x05, 0x78, 0x70, 0x6b, 0xc4, 0x77, 0x2c,
	0xff, 0x1d, 0xd8, 0x26, 0xb8, 0xa9, 0x1a, 0x26, 0x51, 0x4c, 0x55, 0xd7, 0x0c, 0x8a, 0x4f, 0xeb,
	0x18, 0x37, 0xc4, 0x1c, 0xba, 0x0d, 0x28, 0x1e, 0x50, 0x43, 0x0c, 0x26, 0x98, 0x8f, 0xa2, 0x33,
	0xaa, 0x6b, 0x91, 0x3b, 0x8b, 0xaf, 0x85, 0x23, 0x9d, 0x9c, 0x28, 0xa9, 0x6e, 0x89, 0xf7, 0x4a,
	0xd8, 0x54, 0x39, 0xcd, 0xb2, 0x2c, 0xc3, 0x7e, 0x6e, 0x67, 0x1d, 0xc7, 0xcb, 0x16, 0x9e, 0xfc,
	0xef, 0xc9, 0xda, 0x1c, 0x07, 0xf1, 0x63, 0xa4, 0xb9, 0x63, 0x6c, 0xce, 0x4a, 0x70, 0xce, 0x70,
	0xb6, 0x3a, 0x37, 0xd9, 0xbe, 0x86, 0xbd, 0xb7, 0x40, 0xdf, 0xf1, 0x0c, 0x10, 0xac, 0x86, 0x4c,
	0x93, 0xe4, 0x78, 0x5e, 0xde, 0x9b, 0x72, 0xdc, 0x17, 0x1e, 0xf3, 0x2f, 0xe3, 0x8c, 0xfc, 0xa3,
	0x00, 0xbb, 0xb3, 0x10, 0x3c, 0x1d, 0x67, 0xb9, 0x74, 0x28, 0xb3, 0xab, 0x3a, 0xb5, 0x9a, 0xa1,
	0xcb, 0x25, 0xe2, 0x72, 0x4a, 0x43, 0x8d, 0xe1, 0xde, 0x5f, 0x16, 0x1e, 0xbd, 0x80, 0x6a, 0xe6,
	0x1f, 0x2c, 0x71, 0xb7, 0x72, 0xa6, 0xe4, 0xf4, 0xd7, 0xc6, 0x75, 0xf5, 0x48, 0xc5, 0x0d, 0x69,
	0x8e, 0xd3, 0x5f, 0x28, 0x3e, 0x6c, 0xb6, 0xa5, 0x42, 0xc2, 0xa7, 0xfc, 0x53, 0x3c, 0xc5, 0xd4,
	0xba, 0x54, 0x7c, 0xc4, 0x60, 0x35, 0xfb, 0xa4, 0x47, 0x1b, 0x50, 0xc9, 0xf8, 0xd9, 0x29, 0x96,
	0xb8, 0xf1, 0x8a, 0xa6, 0x53, 0xa5, 0xf1, 0x12, 0x13, 0x53, 0x35, 0xb0, 0x54, 0x10, 0xd2, 0x75,
	0x28, 0x6b, 0x3a, 0xc5, 0xa7, 0x9c, 0x71, 0xa5, 0xa2, 0x10, 0x6d, 0x41, 0xb5, 0x63, 0x60, 0xaa,
	0x1d, 0x53, 0x82, 0xbf, 0xc2, 0x75, 0x53, 0x5a, 0xe0, 0xe2, 0x47, 0x4f, 0xc5, 0x3f, 0xc4, 0xf1,
	0x5f, 0x0e, 0x7c, 0x6a, 0xe1, 0xab, 0x88, 0x73, 0x10, 0xbe, 0x8f, 0xb9, 0x04, 0x9f, 0x46, 0x92,
	0xc2, 0xc1, 0xef, 0x97, 0xa1, 0x14, 0x67, 0x14, 0xfd, 0x36, 0x9d, 0x32, 0xd3, 0xe7, 0x26, 0x92,
	0x6f, 0x7d, 0xe8, 0x8a, 0x92, 0xd8, 0xd9, 0x7f, 0xdb, 0x63, 0x58, 0x9e, 0x43, 0x06, 0xac, 0xe5,
	0x9e, 0x67, 0x68, 0x6f, 0xf6, 0x73, 0x2f, 0xf4, 0xfb, 0xe0, 0xd6, 0xf7, 0xa0, 0x3c, 0x87, 0x5e,
	0x88, 0x2d, 0x0b, 0x8d, 0xd2, 0xeb, 0xa1, 0x87, 0x13, 0xf8, 0xcc, 0xd3, 0x6d, 0x67, 0x67, 0xf6,
	0xc8, 0x2e, 0xcf, 0x21, 0x0d, 0x56, 0xd3, 0xea, 0xea, 0xd9, 0x17, 0x37, 0xef, 0xcf, 0x5f, 0x68,
	0xf6, 0xfe, 0xfc, 0x85, 0x2f, 0xc8, 0x29, 0xfe, 0x32, 0x4f, 0xcb, 0xb7, 0xf8, 0x53, 0xd3, 0xe4,
	0x35, 0x59, 0x80, 0x76, 0xa7, 0xcf, 0x51, 0xa1, 0xa7, 0xfb, 0x33, 0x87, 0x2c, 0x79, 0xee, 0xa7,
	0x05, 0x34, 0x4c, 0xff, 0x38, 0xc9, 0xdd, 0x11, 0xe8, 0xe3, 0xb7, 0x5f, 0x6a, 0x61, 0x88, 0x1f,
	0xdd, 0xe9, 0xf6, 0x13, 0xe1, 0xbe, 0x49, 0xff, 0xc5, 0x99, 0x20, 0x44, 0xf4, 0xe9, 0x5d, 0xe8,
	0x37, 0x0c, 0xf9, 0xf1, 0x1d, 0x99, 0x5a, 0x9e, 0x43, 0x97, 0xe9, 0xbf, 0x1b, 0x59, 0xea, 0x41,
	0x1f, 0xbd, 0x95, 0xdf, 0xc2, 0x60, 0x3f, 0xbc, 0x0b, 0x0f, 0xca, 0x73, 0xe7, 0x4b, 0xe2, 0x6f,
	0xc6, 0x67, 0xff, 0x0d, 0x00, 0x00, 0xff, 0xff, 0x96, 0x8c, 0xf6, 0x24, 0xe4, 0x1a, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// BgpRouteClient is the client API for BgpRoute service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type BgpRouteClient interface {
	//* BGP Routing Initialize operation
	//  BgpRouteInitialize() must be called upon connection or reconnection
	//  to the server. If the client is connecting for the first time, the
	//  server will initialize per-client state for the connection.
	//  If the client is reconnecting with the same client name following a
	//  connection fault (having not closed a previous connection with
	//  BgpRouteCleanup), then gateway and route state will be rebound to
	//  the new connection.
	//  In this case, the return status will indicate that state was rebound
	//  and the client need not reply the previous routing state to the
	//  server.
	BgpRouteInitialize(ctx context.Context, in *BgpRouteInitializeRequest, opts ...grpc.CallOption) (*BgpRouteInitializeReply, error)
	//* BGP Routing Cleanup operation
	//  BgpRouteCleanup will purge all gateway and route state for the
	//  client.
	BgpRouteCleanup(ctx context.Context, in *BgpRouteCleanupRequest, opts ...grpc.CallOption) (*BgpRouteCleanupReply, error)
	//* BGP Route Add operation
	//  Add a BGP-Static route to the routing table.
	//  bgp_route_add may be called multiple times for the same prefix to add
	//  multiple paths with distinct path_cookie for the same destination.
	//  If a matching route already exists in the given table, then an error
	//  will be returned.
	//  BgpRouteUpdateRequest may contain from one to 1000 routes
	//  to be added.
	//  If the request contains multiple routes, the routes will
	//  be processed in the order given and the first error encountered will
	//  cause the request to abort.
	//  The API always returns the final status (success or first error
	//  encountered) and the number of routes that were successfully created
	//  prior to any error or full completion of the request.
	BgpRouteAdd(ctx context.Context, in *BgpRouteUpdateRequest, opts ...grpc.CallOption) (*BgpRouteOperReply, error)
	//* BGP Route Modify operation
	// Modify an existing BGP-Static route in the routing table. For each
	// route in the request, if the route_key is matched, the matched route
	// will be updated with the supplied route attributes.
	// If a matching route does not exist in the given table, then an error
	// will be returned.
	// BgpRouteUpdateRequest may contain from one to 1000 routes
	// to be added.
	// If the request contains multiple routes, the routes will
	// be processed in the order given and the first error encountered will
	// cause the request to abort.
	// The API always returns the final status (success or first error
	// encountered) and the number of routes that were successfully modified
	// prior to any error or full completion of the request.
	BgpRouteModify(ctx context.Context, in *BgpRouteUpdateRequest, opts ...grpc.CallOption) (*BgpRouteOperReply, error)
	//* BGP Route Update operation
	//  Create a new BGP-Static route if a matching route does not exist, OR
	//  modify an existing BGP-Static route if it is already present in the
	//  routing table.
	//  BgpRouteUpdateRequest may contain from one to 1000 routes
	//  to be added.
	//  If the request contains multiple routes, the routes will
	//  be processed in the order given and the first error encountered will
	//  cause the request to abort.
	//  The API always returns the final status (success or first error
	//  encountered) and the number of routes that were successfully modified
	//  prior to any error or full completion of the request.
	BgpRouteUpdate(ctx context.Context, in *BgpRouteUpdateRequest, opts ...grpc.CallOption) (*BgpRouteOperReply, error)
	//* BGP Route Remove operation
	//  Remove a BGP-Static route from the routing table.
	//  BgpRouteRemove may be called multiple times for the same prefix
	//  to remove multiple paths with distinct path_cookie for the same
	//  destination.
	//  The request may contain from one to 1000 routes
	//  to be removed.
	//  If the request contains multiple routes, the routes will
	//  be processed in the order given and the first error encountered will
	//  cause the request to abort.
	//  The API always returns the final status (success or first error
	//  encountered) and the number of routes that were successfully modified
	//  prior to any error or full completion of the request.
	BgpRouteRemove(ctx context.Context, in *BgpRouteRemoveRequest, opts ...grpc.CallOption) (*BgpRouteOperReply, error)
	//* BGP Route Get operation
	//  Lookup a BGP or BGP-Static protocol route from the routing table.
	//  All match parameters are optional.
	//  Match fields that are not specified or that
	//  may match more than one route (e.g. a less-specific destination
	//  prefix) may result in multiple routes being returned in the replies.
	//  Only BGP and BGP-Static routes will be matched.
	//  Replies are streamed until all match routes have been sent. The
	//  client will receive a final null message once all routes have
	//  been received.
	//  The server's walk of search results is not atomic so route changes
	//  during streaming and consumption of replies may or may not be
	//  reflected in the results.
	//  See BgpRouteGetReply.
	BgpRouteGet(ctx context.Context, in *BgpRouteGetRequest, opts ...grpc.CallOption) (BgpRoute_BgpRouteGetClient, error)
	//*
	//  BGP Route Monitoring Registration
	//  Register to receive updates streamed from BGP when routes matching
	//  the bgp-import "analyze" policy action are added, modified, or
	//  withdrawn by BGP peers.
	//  Updates will be streamed as BgpRouteMonitorRegisterReply mesages
	//  BgpRouteMonitorUnregister() is called.
	//  Upon initial registration, a full download of route ADD operations for
	//  all routes matching the "analyze" import policy action will be
	//  streamed, followed by a closing END_OF_RIB operation. Subsequently,
	//  incremental updates will be streamed whenever BGP advertisements
	//  from peers are added, modified, or withdrawn, or when BGP import
	//  "analyze" policy is changed.
	//  There is no strict ordering of routes in the update stream and
	//  state compression is applied when applicable to a set of operations.
	BgpRouteMonitorRegister(ctx context.Context, in *BgpRouteMonitorRegisterRequest, opts ...grpc.CallOption) (BgpRoute_BgpRouteMonitorRegisterClient, error)
	//*
	// BGP Route Monitoring Unregistration
	// Generated client API: BgpRouteMonitorUnregister()
	// Unregister to receive updates streamed from BGP when routes are
	// added, modified, or withdrawn by BGP peers.
	BgpRouteMonitorUnregister(ctx context.Context, in *BgpRouteMonitorUnregisterRequest, opts ...grpc.CallOption) (*BgpRouteMonitorUnregisterReply, error)
	//*
	// BGP Route Monitoring Refresh
	// Generated client API: BgpRouteMonitorRefresh()
	// Request to refresh all route monitoring entries to the client.
	BgpRouteMonitorRefresh(ctx context.Context, in *BgpRouteMonitorRefreshRequest, opts ...grpc.CallOption) (*BgpRouteMonitorRefreshReply, error)
}

type bgpRouteClient struct {
	cc *grpc.ClientConn
}

func NewBgpRouteClient(cc *grpc.ClientConn) BgpRouteClient {
	return &bgpRouteClient{cc}
}

func (c *bgpRouteClient) BgpRouteInitialize(ctx context.Context, in *BgpRouteInitializeRequest, opts ...grpc.CallOption) (*BgpRouteInitializeReply, error) {
	out := new(BgpRouteInitializeReply)
	err := c.cc.Invoke(ctx, "/routing.BgpRoute/BgpRouteInitialize", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bgpRouteClient) BgpRouteCleanup(ctx context.Context, in *BgpRouteCleanupRequest, opts ...grpc.CallOption) (*BgpRouteCleanupReply, error) {
	out := new(BgpRouteCleanupReply)
	err := c.cc.Invoke(ctx, "/routing.BgpRoute/BgpRouteCleanup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bgpRouteClient) BgpRouteAdd(ctx context.Context, in *BgpRouteUpdateRequest, opts ...grpc.CallOption) (*BgpRouteOperReply, error) {
	out := new(BgpRouteOperReply)
	err := c.cc.Invoke(ctx, "/routing.BgpRoute/BgpRouteAdd", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bgpRouteClient) BgpRouteModify(ctx context.Context, in *BgpRouteUpdateRequest, opts ...grpc.CallOption) (*BgpRouteOperReply, error) {
	out := new(BgpRouteOperReply)
	err := c.cc.Invoke(ctx, "/routing.BgpRoute/BgpRouteModify", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bgpRouteClient) BgpRouteUpdate(ctx context.Context, in *BgpRouteUpdateRequest, opts ...grpc.CallOption) (*BgpRouteOperReply, error) {
	out := new(BgpRouteOperReply)
	err := c.cc.Invoke(ctx, "/routing.BgpRoute/BgpRouteUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bgpRouteClient) BgpRouteRemove(ctx context.Context, in *BgpRouteRemoveRequest, opts ...grpc.CallOption) (*BgpRouteOperReply, error) {
	out := new(BgpRouteOperReply)
	err := c.cc.Invoke(ctx, "/routing.BgpRoute/BgpRouteRemove", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bgpRouteClient) BgpRouteGet(ctx context.Context, in *BgpRouteGetRequest, opts ...grpc.CallOption) (BgpRoute_BgpRouteGetClient, error) {
	stream, err := c.cc.NewStream(ctx, &_BgpRoute_serviceDesc.Streams[0], "/routing.BgpRoute/BgpRouteGet", opts...)
	if err != nil {
		return nil, err
	}
	x := &bgpRouteBgpRouteGetClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type BgpRoute_BgpRouteGetClient interface {
	Recv() (*BgpRouteGetReply, error)
	grpc.ClientStream
}

type bgpRouteBgpRouteGetClient struct {
	grpc.ClientStream
}

func (x *bgpRouteBgpRouteGetClient) Recv() (*BgpRouteGetReply, error) {
	m := new(BgpRouteGetReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *bgpRouteClient) BgpRouteMonitorRegister(ctx context.Context, in *BgpRouteMonitorRegisterRequest, opts ...grpc.CallOption) (BgpRoute_BgpRouteMonitorRegisterClient, error) {
	stream, err := c.cc.NewStream(ctx, &_BgpRoute_serviceDesc.Streams[1], "/routing.BgpRoute/BgpRouteMonitorRegister", opts...)
	if err != nil {
		return nil, err
	}
	x := &bgpRouteBgpRouteMonitorRegisterClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type BgpRoute_BgpRouteMonitorRegisterClient interface {
	Recv() (*BgpRouteMonitorRegisterReply, error)
	grpc.ClientStream
}

type bgpRouteBgpRouteMonitorRegisterClient struct {
	grpc.ClientStream
}

func (x *bgpRouteBgpRouteMonitorRegisterClient) Recv() (*BgpRouteMonitorRegisterReply, error) {
	m := new(BgpRouteMonitorRegisterReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *bgpRouteClient) BgpRouteMonitorUnregister(ctx context.Context, in *BgpRouteMonitorUnregisterRequest, opts ...grpc.CallOption) (*BgpRouteMonitorUnregisterReply, error) {
	out := new(BgpRouteMonitorUnregisterReply)
	err := c.cc.Invoke(ctx, "/routing.BgpRoute/BgpRouteMonitorUnregister", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bgpRouteClient) BgpRouteMonitorRefresh(ctx context.Context, in *BgpRouteMonitorRefreshRequest, opts ...grpc.CallOption) (*BgpRouteMonitorRefreshReply, error) {
	out := new(BgpRouteMonitorRefreshReply)
	err := c.cc.Invoke(ctx, "/routing.BgpRoute/BgpRouteMonitorRefresh", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BgpRouteServer is the server API for BgpRoute service.
type BgpRouteServer interface {
	//* BGP Routing Initialize operation
	//  BgpRouteInitialize() must be called upon connection or reconnection
	//  to the server. If the client is connecting for the first time, the
	//  server will initialize per-client state for the connection.
	//  If the client is reconnecting with the same client name following a
	//  connection fault (having not closed a previous connection with
	//  BgpRouteCleanup), then gateway and route state will be rebound to
	//  the new connection.
	//  In this case, the return status will indicate that state was rebound
	//  and the client need not reply the previous routing state to the
	//  server.
	BgpRouteInitialize(context.Context, *BgpRouteInitializeRequest) (*BgpRouteInitializeReply, error)
	//* BGP Routing Cleanup operation
	//  BgpRouteCleanup will purge all gateway and route state for the
	//  client.
	BgpRouteCleanup(context.Context, *BgpRouteCleanupRequest) (*BgpRouteCleanupReply, error)
	//* BGP Route Add operation
	//  Add a BGP-Static route to the routing table.
	//  bgp_route_add may be called multiple times for the same prefix to add
	//  multiple paths with distinct path_cookie for the same destination.
	//  If a matching route already exists in the given table, then an error
	//  will be returned.
	//  BgpRouteUpdateRequest may contain from one to 1000 routes
	//  to be added.
	//  If the request contains multiple routes, the routes will
	//  be processed in the order given and the first error encountered will
	//  cause the request to abort.
	//  The API always returns the final status (success or first error
	//  encountered) and the number of routes that were successfully created
	//  prior to any error or full completion of the request.
	BgpRouteAdd(context.Context, *BgpRouteUpdateRequest) (*BgpRouteOperReply, error)
	//* BGP Route Modify operation
	// Modify an existing BGP-Static route in the routing table. For each
	// route in the request, if the route_key is matched, the matched route
	// will be updated with the supplied route attributes.
	// If a matching route does not exist in the given table, then an error
	// will be returned.
	// BgpRouteUpdateRequest may contain from one to 1000 routes
	// to be added.
	// If the request contains multiple routes, the routes will
	// be processed in the order given and the first error encountered will
	// cause the request to abort.
	// The API always returns the final status (success or first error
	// encountered) and the number of routes that were successfully modified
	// prior to any error or full completion of the request.
	BgpRouteModify(context.Context, *BgpRouteUpdateRequest) (*BgpRouteOperReply, error)
	//* BGP Route Update operation
	//  Create a new BGP-Static route if a matching route does not exist, OR
	//  modify an existing BGP-Static route if it is already present in the
	//  routing table.
	//  BgpRouteUpdateRequest may contain from one to 1000 routes
	//  to be added.
	//  If the request contains multiple routes, the routes will
	//  be processed in the order given and the first error encountered will
	//  cause the request to abort.
	//  The API always returns the final status (success or first error
	//  encountered) and the number of routes that were successfully modified
	//  prior to any error or full completion of the request.
	BgpRouteUpdate(context.Context, *BgpRouteUpdateRequest) (*BgpRouteOperReply, error)
	//* BGP Route Remove operation
	//  Remove a BGP-Static route from the routing table.
	//  BgpRouteRemove may be called multiple times for the same prefix
	//  to remove multiple paths with distinct path_cookie for the same
	//  destination.
	//  The request may contain from one to 1000 routes
	//  to be removed.
	//  If the request contains multiple routes, the routes will
	//  be processed in the order given and the first error encountered will
	//  cause the request to abort.
	//  The API always returns the final status (success or first error
	//  encountered) and the number of routes that were successfully modified
	//  prior to any error or full completion of the request.
	BgpRouteRemove(context.Context, *BgpRouteRemoveRequest) (*BgpRouteOperReply, error)
	//* BGP Route Get operation
	//  Lookup a BGP or BGP-Static protocol route from the routing table.
	//  All match parameters are optional.
	//  Match fields that are not specified or that
	//  may match more than one route (e.g. a less-specific destination
	//  prefix) may result in multiple routes being returned in the replies.
	//  Only BGP and BGP-Static routes will be matched.
	//  Replies are streamed until all match routes have been sent. The
	//  client will receive a final null message once all routes have
	//  been received.
	//  The server's walk of search results is not atomic so route changes
	//  during streaming and consumption of replies may or may not be
	//  reflected in the results.
	//  See BgpRouteGetReply.
	BgpRouteGet(*BgpRouteGetRequest, BgpRoute_BgpRouteGetServer) error
	//*
	//  BGP Route Monitoring Registration
	//  Register to receive updates streamed from BGP when routes matching
	//  the bgp-import "analyze" policy action are added, modified, or
	//  withdrawn by BGP peers.
	//  Updates will be streamed as BgpRouteMonitorRegisterReply mesages
	//  BgpRouteMonitorUnregister() is called.
	//  Upon initial registration, a full download of route ADD operations for
	//  all routes matching the "analyze" import policy action will be
	//  streamed, followed by a closing END_OF_RIB operation. Subsequently,
	//  incremental updates will be streamed whenever BGP advertisements
	//  from peers are added, modified, or withdrawn, or when BGP import
	//  "analyze" policy is changed.
	//  There is no strict ordering of routes in the update stream and
	//  state compression is applied when applicable to a set of operations.
	BgpRouteMonitorRegister(*BgpRouteMonitorRegisterRequest, BgpRoute_BgpRouteMonitorRegisterServer) error
	//*
	// BGP Route Monitoring Unregistration
	// Generated client API: BgpRouteMonitorUnregister()
	// Unregister to receive updates streamed from BGP when routes are
	// added, modified, or withdrawn by BGP peers.
	BgpRouteMonitorUnregister(context.Context, *BgpRouteMonitorUnregisterRequest) (*BgpRouteMonitorUnregisterReply, error)
	//*
	// BGP Route Monitoring Refresh
	// Generated client API: BgpRouteMonitorRefresh()
	// Request to refresh all route monitoring entries to the client.
	BgpRouteMonitorRefresh(context.Context, *BgpRouteMonitorRefreshRequest) (*BgpRouteMonitorRefreshReply, error)
}

func RegisterBgpRouteServer(s *grpc.Server, srv BgpRouteServer) {
	s.RegisterService(&_BgpRoute_serviceDesc, srv)
}

func _BgpRoute_BgpRouteInitialize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BgpRouteInitializeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BgpRouteServer).BgpRouteInitialize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/routing.BgpRoute/BgpRouteInitialize",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BgpRouteServer).BgpRouteInitialize(ctx, req.(*BgpRouteInitializeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BgpRoute_BgpRouteCleanup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BgpRouteCleanupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BgpRouteServer).BgpRouteCleanup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/routing.BgpRoute/BgpRouteCleanup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BgpRouteServer).BgpRouteCleanup(ctx, req.(*BgpRouteCleanupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BgpRoute_BgpRouteAdd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BgpRouteUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BgpRouteServer).BgpRouteAdd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/routing.BgpRoute/BgpRouteAdd",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BgpRouteServer).BgpRouteAdd(ctx, req.(*BgpRouteUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BgpRoute_BgpRouteModify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BgpRouteUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BgpRouteServer).BgpRouteModify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/routing.BgpRoute/BgpRouteModify",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BgpRouteServer).BgpRouteModify(ctx, req.(*BgpRouteUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BgpRoute_BgpRouteUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BgpRouteUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BgpRouteServer).BgpRouteUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/routing.BgpRoute/BgpRouteUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BgpRouteServer).BgpRouteUpdate(ctx, req.(*BgpRouteUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BgpRoute_BgpRouteRemove_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BgpRouteRemoveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BgpRouteServer).BgpRouteRemove(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/routing.BgpRoute/BgpRouteRemove",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BgpRouteServer).BgpRouteRemove(ctx, req.(*BgpRouteRemoveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BgpRoute_BgpRouteGet_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BgpRouteGetRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BgpRouteServer).BgpRouteGet(m, &bgpRouteBgpRouteGetServer{stream})
}

type BgpRoute_BgpRouteGetServer interface {
	Send(*BgpRouteGetReply) error
	grpc.ServerStream
}

type bgpRouteBgpRouteGetServer struct {
	grpc.ServerStream
}

func (x *bgpRouteBgpRouteGetServer) Send(m *BgpRouteGetReply) error {
	return x.ServerStream.SendMsg(m)
}

func _BgpRoute_BgpRouteMonitorRegister_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BgpRouteMonitorRegisterRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BgpRouteServer).BgpRouteMonitorRegister(m, &bgpRouteBgpRouteMonitorRegisterServer{stream})
}

type BgpRoute_BgpRouteMonitorRegisterServer interface {
	Send(*BgpRouteMonitorRegisterReply) error
	grpc.ServerStream
}

type bgpRouteBgpRouteMonitorRegisterServer struct {
	grpc.ServerStream
}

func (x *bgpRouteBgpRouteMonitorRegisterServer) Send(m *BgpRouteMonitorRegisterReply) error {
	return x.ServerStream.SendMsg(m)
}

func _BgpRoute_BgpRouteMonitorUnregister_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BgpRouteMonitorUnregisterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BgpRouteServer).BgpRouteMonitorUnregister(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/routing.BgpRoute/BgpRouteMonitorUnregister",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BgpRouteServer).BgpRouteMonitorUnregister(ctx, req.(*BgpRouteMonitorUnregisterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BgpRoute_BgpRouteMonitorRefresh_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BgpRouteMonitorRefreshRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BgpRouteServer).BgpRouteMonitorRefresh(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/routing.BgpRoute/BgpRouteMonitorRefresh",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BgpRouteServer).BgpRouteMonitorRefresh(ctx, req.(*BgpRouteMonitorRefreshRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _BgpRoute_serviceDesc = grpc.ServiceDesc{
	ServiceName: "routing.BgpRoute",
	HandlerType: (*BgpRouteServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "BgpRouteInitialize",
			Handler:    _BgpRoute_BgpRouteInitialize_Handler,
		},
		{
			MethodName: "BgpRouteCleanup",
			Handler:    _BgpRoute_BgpRouteCleanup_Handler,
		},
		{
			MethodName: "BgpRouteAdd",
			Handler:    _BgpRoute_BgpRouteAdd_Handler,
		},
		{
			MethodName: "BgpRouteModify",
			Handler:    _BgpRoute_BgpRouteModify_Handler,
		},
		{
			MethodName: "BgpRouteUpdate",
			Handler:    _BgpRoute_BgpRouteUpdate_Handler,
		},
		{
			MethodName: "BgpRouteRemove",
			Handler:    _BgpRoute_BgpRouteRemove_Handler,
		},
		{
			MethodName: "BgpRouteMonitorUnregister",
			Handler:    _BgpRoute_BgpRouteMonitorUnregister_Handler,
		},
		{
			MethodName: "BgpRouteMonitorRefresh",
			Handler:    _BgpRoute_BgpRouteMonitorRefresh_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "BgpRouteGet",
			Handler:       _BgpRoute_BgpRouteGet_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "BgpRouteMonitorRegister",
			Handler:       _BgpRoute_BgpRouteMonitorRegister_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "bgp_route_service.proto",
}
